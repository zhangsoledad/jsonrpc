var searchIndex = {};
searchIndex["jsonrpc"] = {"doc":"Parity JSON-RPC 2.0 Implementation","items":[],"paths":[]};
searchIndex["jsonrpc_core"] = {"doc":"Transport agnostic jsonrpc library.","items":[[3,"IoHandler","jsonrpc_core","Simplified `IoHandler` with no `Metadata` associated with each request.",null,null],[3,"MetaIoHandler","","Request handler",null,null],[3,"NoopMiddleware","","No-op middleware implementation",null,null],[4,"RemoteProcedure","","Possible Remote Procedures with Metadata",null,null],[13,"Method","","A method call",0,null],[13,"Notification","","A notification",0,null],[13,"Alias","","An alias to other method,",0,null],[4,"Compatibility","","`IoHandler` json-rpc protocol compatibility",null,null],[13,"V1","","Compatible only with JSON-RPC 1.x",1,null],[13,"V2","","Compatible only with JSON-RPC 2.0",1,null],[13,"Both","","Compatible with both",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"compatibility"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"with_compatibility","","Creates new `MetaIoHandler` compatible with specified protocol version.",2,{"inputs":[{"name":"compatibility"}],"output":{"name":"self"}}],[11,"new","","Creates new `MetaIoHandler`",2,{"inputs":[{"name":"compatibility"},{"name":"s"}],"output":{"name":"self"}}],[11,"with_middleware","","Creates new `MetaIoHandler` with specified middleware.",2,{"inputs":[{"name":"s"}],"output":{"name":"self"}}],[11,"add_alias","","Adds an alias to a method.",2,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"}],"output":null}],[11,"add_method","","Adds new supported synchronous method",2,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"add_async_method","","Adds new supported asynchronous method",2,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"add_notification","","Adds new supported notification",2,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"add_method_with_meta","","Adds new supported asynchronous method with metadata support.",2,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"add_notification_with_meta","","Adds new supported notification with metadata support.",2,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"extend_with","","Extend this `MetaIoHandler` with methods defined elsewhere.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"handle_request_sync","","Handle given request synchronously - will block until response is available. If you have any asynchronous methods in your RPC it is much wiser to use `handle_request` instead and deal with asynchronous requests in a non-blocking fashion.",2,{"inputs":[{"name":"self"},{"name":"str"},{"name":"t"}],"output":{"name":"option"}}],[11,"handle_request","","Handle given request asynchronously.",2,{"inputs":[{"name":"self"},{"name":"str"},{"name":"t"}],"output":{"name":"boxfuture"}}],[11,"handle_rpc_request","","Handle deserialized RPC request.",2,{"inputs":[{"name":"self"},{"name":"request"},{"name":"t"}],"output":{"name":"futureresponse"}}],[11,"handle_call","","Handle single call asynchronously.",2,{"inputs":[{"name":"self"},{"name":"call"},{"name":"t"}],"output":{"name":"boxfuture"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"iohandler"}}],[11,"new","","Creates new `IoHandler` without any metadata.",3,{"inputs":[],"output":{"name":"self"}}],[11,"with_compatibility","","Creates new `IoHandler` without any metadata compatible with specified protocol version.",3,{"inputs":[{"name":"compatibility"}],"output":{"name":"self"}}],[11,"handle_request","","Handle given string request asynchronously.",3,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"boxfuture"}}],[11,"handle_rpc_request","","Handle deserialized RPC request asynchronously.",3,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"futureresponse"}}],[11,"handle_call","","Handle single Call asynchronously.",3,{"inputs":[{"name":"self"},{"name":"call"}],"output":{"name":"boxfuture"}}],[11,"handle_request_sync","","Handle given request synchronously - will block until response is available. If you have any asynchronous methods in your RPC it is much wiser to use `handle_request` instead and deal with asynchronous requests in a non-blocking fashion.",3,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"deref","","",3,null],[11,"deref_mut","","",3,null],[11,"from","","",2,{"inputs":[{"name":"iohandler"}],"output":{"name":"self"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"noop"}}],[11,"on_request","","",4,{"inputs":[{"name":"self"},{"name":"request"},{"name":"m"},{"name":"f"}],"output":{"name":"futureresponse"}}],[0,"types","","JSON-RPC types",null,null],[4,"Value","jsonrpc_core::types","Represents any valid JSON value.",null,null],[13,"Null","","Represents a JSON null value.",5,null],[13,"Bool","","Represents a JSON boolean.",5,null],[13,"Number","","Represents a JSON number, whether integer or floating point.",5,null],[13,"String","","Represents a JSON string.",5,null],[13,"Array","","Represents a JSON array.",5,null],[13,"Object","","Represents a JSON object.",5,null],[5,"to_value","","Convert a `T` into `serde_json::Value` which is an enum that can represent any valid JSON data.",null,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[5,"to_string","","Serialize the given data structure as a String of JSON.",null,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[0,"error","","jsonrpc errors",null,null],[3,"Error","jsonrpc_core::types::error","Error object as defined in Spec",null,null],[12,"code","","Code",6,null],[12,"message","","Message",6,null],[12,"data","","Optional data",6,null],[4,"ErrorCode","","JSONRPC error code",null,null],[13,"ParseError","","Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",7,null],[13,"InvalidRequest","","The JSON sent is not a valid Request object.",7,null],[13,"MethodNotFound","","The method does not exist / is not available.",7,null],[13,"InvalidParams","","Invalid method parameter(s).",7,null],[13,"InternalError","","Internal JSON-RPC error.",7,null],[13,"ServerError","","Reserved for implementation-defined server-errors.",7,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"errorcode"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"errorcode"}],"output":{"name":"bool"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"errorcode"}}],[11,"code","","Returns integer code value",7,{"inputs":[{"name":"self"}],"output":{"name":"i64"}}],[11,"description","","Returns human-readable description",7,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"deserialize","","",7,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"serialize","","",7,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"new","","Wraps given `ErrorCode`",6,{"inputs":[{"name":"errorcode"}],"output":{"name":"self"}}],[11,"parse_error","","Creates new `ParseError`",6,{"inputs":[],"output":{"name":"self"}}],[11,"invalid_request","","Creates new `InvalidRequest`",6,{"inputs":[],"output":{"name":"self"}}],[11,"method_not_found","","Creates new `MethodNotFound`",6,{"inputs":[],"output":{"name":"self"}}],[11,"invalid_params","","Creates new `InvalidParams`",6,{"inputs":[{"name":"m"}],"output":{"name":"self"}}],[11,"internal_error","","Creates new `InternalError`",6,{"inputs":[],"output":{"name":"self"}}],[11,"invalid_version","","Creates new `InvalidRequest` with invalid version description",6,{"inputs":[],"output":{"name":"self"}}],[0,"id","jsonrpc_core::types","jsonrpc id field",null,null],[4,"Id","jsonrpc_core::types::id","Request Id",null,null],[13,"Null","","No id (notification)",8,null],[13,"Str","","String id",8,null],[13,"Num","","Numeric id",8,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"serialize","","",8,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",8,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[0,"params","jsonrpc_core::types","jsonrpc params field",null,null],[4,"Params","jsonrpc_core::types::params","Request parameters",null,null],[13,"Array","","Array of values",9,null],[13,"Map","","Map of values",9,null],[13,"None","","No parameters",9,null],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"params"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"params"}],"output":{"name":"bool"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"params"}}],[11,"parse","","Parse incoming `Params` into expected types.",9,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"serialize","","",9,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",9,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[0,"request","jsonrpc_core::types","jsonrpc request",null,null],[3,"MethodCall","jsonrpc_core::types::request","Represents jsonrpc request which is a method call.",null,null],[12,"jsonrpc","","A String specifying the version of the JSON-RPC protocol.",10,null],[12,"method","","A String containing the name of the method to be invoked.",10,null],[12,"params","","A Structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted.",10,null],[12,"id","","An identifier established by the Client that MUST contain a String, Number, or NULL value if included. If it is not included it is assumed to be a notification.",10,null],[3,"Notification","","Represents jsonrpc request which is a notification.",null,null],[12,"jsonrpc","","A String specifying the version of the JSON-RPC protocol.",11,null],[12,"method","","A String containing the name of the method to be invoked.",11,null],[12,"params","","A Structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted.",11,null],[4,"Call","","Represents single jsonrpc call.",null,null],[13,"MethodCall","","Call method",12,null],[13,"Notification","","Fire notification",12,null],[13,"Invalid","","Invalid call",12,null],[4,"Request","","Represents jsonrpc request.",null,null],[13,"Single","","Single request (call)",13,null],[13,"Batch","","Batch of requests (calls)",13,null],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"methodcall"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"methodcall"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"notification"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"notification"}],"output":{"name":"bool"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"call"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"call"}],"output":{"name":"bool"}}],[11,"from","","",12,{"inputs":[{"name":"methodcall"}],"output":{"name":"self"}}],[11,"from","","",12,{"inputs":[{"name":"notification"}],"output":{"name":"self"}}],[11,"serialize","","",12,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",12,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"bool"}}],[11,"serialize","","",13,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",13,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[0,"response","jsonrpc_core::types","jsonrpc response",null,null],[3,"Success","jsonrpc_core::types::response","Successful response",null,null],[12,"jsonrpc","","Protocol version",14,null],[12,"result","","Result",14,null],[12,"id","","Correlation id",14,null],[3,"Failure","","Unsuccessful response",null,null],[12,"jsonrpc","","Protocol Version",15,null],[12,"error","","Error",15,null],[12,"id","","Correlation id",15,null],[4,"Output","","Represents output - failure or success",null,null],[13,"Success","","Success",16,null],[13,"Failure","","Failure",16,null],[4,"Response","","Synchronous response",null,null],[13,"Single","","Single response",17,null],[13,"Batch","","Response to batch request (batch of responses)",17,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"success"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"success"}],"output":{"name":"bool"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"success"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"failure"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"failure"}],"output":{"name":"bool"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"failure"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"output"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"output"}],"output":{"name":"bool"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"output"}}],[11,"from","","Creates new output given `Result`, `Id` and `Version`.",16,{"inputs":[{"name":"result"},{"name":"id"},{"name":"option"}],"output":{"name":"self"}}],[11,"invalid_request","","Creates new failure output indicating malformed request.",16,{"inputs":[{"name":"id"},{"name":"option"}],"output":{"name":"self"}}],[11,"deserialize","","",16,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"serialize","","",16,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"response"}],"output":{"name":"bool"}}],[11,"ne","","",17,{"inputs":[{"name":"self"},{"name":"response"}],"output":{"name":"bool"}}],[11,"deserialize","","",17,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"serialize","","",17,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"from","","Creates new `Response` with given error and `Version`",17,{"inputs":[{"name":"error"},{"name":"option"}],"output":{"name":"self"}}],[11,"from","","",17,{"inputs":[{"name":"failure"}],"output":{"name":"self"}}],[11,"from","","",17,{"inputs":[{"name":"success"}],"output":{"name":"self"}}],[0,"version","jsonrpc_core::types","jsonrpc version field",null,null],[4,"Version","jsonrpc_core::types::version","Protocol Version",null,null],[13,"V2","","JSONRPC 2.0",18,null],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"version"}],"output":{"name":"bool"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"version"}}],[11,"serialize","","",18,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",18,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[6,"FutureResponse","jsonrpc_core","Type representing middleware or RPC response before serialization.",null,null],[8,"Metadata","","Metadata trait",null,null],[8,"RpcMethodSync","","Synchronous Method",null,null],[10,"call","","Call method",19,{"inputs":[{"name":"self"},{"name":"params"}],"output":{"name":"result"}}],[8,"RpcMethodSimple","","Asynchronous Method",null,null],[10,"call","","Call method",20,{"inputs":[{"name":"self"},{"name":"params"}],"output":{"name":"boxfuture"}}],[8,"RpcMethod","","Asynchronous Method with Metadata",null,null],[10,"call","","Call method",21,{"inputs":[{"name":"self"},{"name":"params"},{"name":"t"}],"output":{"name":"boxfuture"}}],[8,"RpcNotificationSimple","","Notification",null,null],[10,"execute","","Execute notification",22,{"inputs":[{"name":"self"},{"name":"params"}],"output":null}],[8,"RpcNotification","","Notification with Metadata",null,null],[10,"execute","","Execute notification",23,{"inputs":[{"name":"self"},{"name":"params"},{"name":"t"}],"output":null}],[8,"Middleware","","RPC middleware",null,null],[10,"on_request","","Method invoked on each request. Allows you to either respond directly (without executing RPC call) or do any additional work before and/or after processing the request.",24,{"inputs":[{"name":"self"},{"name":"request"},{"name":"m"},{"name":"f"}],"output":{"name":"futureresponse"}}],[11,"get","jsonrpc_core::types","Index into a JSON array or map. A string index can be used to access a value in a map, and a usize index can be used to access an element of an array.",5,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[11,"get_mut","","Mutably index into a JSON array or map. A string index can be used to access a value in a map, and a usize index can be used to access an element of an array.",5,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[11,"is_object","","Returns true if the `Value` is an Object. Returns false otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_object","","If the `Value` is an Object, returns the associated Map. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_object_mut","","If the `Value` is an Object, returns the associated mutable Map. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_array","","Returns true if the `Value` is an Array. Returns false otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_array","","If the `Value` is an Array, returns the associated vector. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_array_mut","","If the `Value` is an Array, returns the associated mutable vector. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_string","","Returns true if the `Value` is a String. Returns false otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_str","","If the `Value` is a String, returns the associated str. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_number","","Returns true if the `Value` is a Number. Returns false otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_i64","","Returns true if the `Value` is an integer between `i64::MIN` and `i64::MAX`.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_u64","","Returns true if the `Value` is an integer between zero and `u64::MAX`.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_f64","","Returns true if the `Value` is a number that can be represented by f64.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_i64","","If the `Value` is an integer, represent it as i64 if possible. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_u64","","If the `Value` is an integer, represent it as u64 if possible. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_f64","","If the `Value` is a number, represent it as f64 if possible. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_boolean","","Returns true if the `Value` is a Boolean. Returns false otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_bool","","If the `Value` is a Boolean, returns the associated bool. Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_null","","Returns true if the `Value` is a Null. Returns false otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_null","","If the `Value` is a Null, returns (). Returns None otherwise.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"pointer","","Looks up a value by a JSON Pointer.",5,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"pointer_mut","","Looks up a value by a JSON Pointer and returns a mutable reference to that value.",5,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"deserialize","","",5,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"index_mut","","Write into a `serde_json::Value` using the syntax `value[0] = ...` or `value[\"k\"] = ...`.",5,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"value"}}],[11,"serialize","","",5,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize_any","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_option","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_enum","","",5,null],[11,"deserialize_newtype_struct","","",5,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_bool","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i8","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i16","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i32","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i64","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u8","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u16","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u32","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u64","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_f32","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_f64","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_char","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_str","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_string","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_bytes","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_byte_buf","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_unit","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_unit_struct","","",5,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_seq","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_tuple","","",5,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_tuple_struct","","",5,{"inputs":[{"name":"self"},{"name":"str"},{"name":"usize"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_map","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_struct","","",5,null],[11,"deserialize_identifier","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_ignored_any","","",5,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"index","","Index into a `serde_json::Value` using the syntax `value[0]` or `value[\"k\"]`.",5,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"value"}}],[11,"fmt","","Display a JSON value as a string.",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"value"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"i16"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"isize"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"bool"}}],[11,"from_str","","",5,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from","","Convert 32-bit floating point number to `Value`",5,{"inputs":[{"name":"f32"}],"output":{"name":"value"}}],[11,"from","","Convert 64-bit floating point number to `Value`",5,{"inputs":[{"name":"f64"}],"output":{"name":"value"}}],[11,"from","","Convert boolean to `Value`",5,{"inputs":[{"name":"bool"}],"output":{"name":"value"}}],[11,"from","","Convert `String` to `Value`",5,{"inputs":[{"name":"string"}],"output":{"name":"value"}}],[11,"from","","Convert string slice to `Value`",5,{"inputs":[{"name":"str"}],"output":{"name":"value"}}],[11,"from","","Convert copy-on-write string to `Value`",5,{"inputs":[{"name":"cow"}],"output":{"name":"value"}}],[11,"from","","Convert map (with string keys) to `Value`",5,{"inputs":[{"name":"map"}],"output":{"name":"value"}}],[11,"from","","Convert a `Vec` to `Value`",5,{"inputs":[{"name":"vec"}],"output":{"name":"value"}}],[11,"from","","Convert a slice to `Value`",5,null],[11,"from","","",5,{"inputs":[{"name":"i8"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"i16"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"i32"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"i64"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"isize"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"u8"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"u16"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"u32"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"u64"}],"output":{"name":"value"}}],[11,"from","","",5,{"inputs":[{"name":"usize"}],"output":{"name":"value"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",5,{"inputs":[],"output":{"name":"value"}}],[11,"from_iter","","Convert an iteratable type to a `Value`",5,{"inputs":[{"name":"i"}],"output":{"name":"value"}}]],"paths":[[4,"RemoteProcedure"],[4,"Compatibility"],[3,"MetaIoHandler"],[3,"IoHandler"],[3,"NoopMiddleware"],[4,"Value"],[3,"Error"],[4,"ErrorCode"],[4,"Id"],[4,"Params"],[3,"MethodCall"],[3,"Notification"],[4,"Call"],[4,"Request"],[3,"Success"],[3,"Failure"],[4,"Output"],[4,"Response"],[4,"Version"],[8,"RpcMethodSync"],[8,"RpcMethodSimple"],[8,"RpcMethod"],[8,"RpcNotificationSimple"],[8,"RpcNotification"],[8,"Middleware"]]};
searchIndex["jsonrpc_http_server"] = {"doc":"jsonrpc http server.","items":[[3,"Host","jsonrpc_http_server","Host type",null,null],[4,"DomainsValidation","","Specifies if domains should be validated.",null,null],[13,"AllowOnly","","Allow only domains on the list.",0,null],[13,"Disabled","","Disable domains validation completely.",0,null],[4,"AccessControlAllowOrigin","","Origins allowed to access",null,null],[13,"Value","","Specific hostname",1,null],[13,"Null","","null-origin (file:///, sandboxed iframe)",1,null],[13,"Any","","Any non-null origin",1,null],[3,"Origin","","Request Origin",null,null],[0,"io","jsonrpc_http_server::tokio_core","I/O conveniences when working with primitives in `tokio-core`",null,null],[6,"IoFuture","jsonrpc_http_server::tokio_core::io","A convenience typedef around a `Future` whose error component is `io::Error`",null,null],[6,"IoStream","","A convenience typedef around a `Stream` whose error component is `io::Error`",null,null],[8,"Io","","A trait for read/write I/O objects",null,null],[11,"poll_read","","Tests to see if this I/O object may be readable.",2,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Tests to see if this I/O object may be writable.",2,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"read_vec","","Read in a list of buffers all at once.",2,null],[11,"write_vec","","Write a list of buffers all at once.",2,null],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",2,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"framed"}}],[11,"split","","Helper method for splitting this read/write object into two halves.",2,null],[5,"read","","Tries to read some bytes directly into the given `buf` in asynchronous manner, returning a future type.",null,{"inputs":[{"name":"r"},{"name":"t"}],"output":{"name":"read"}}],[3,"Copy","","A future which will copy all data from a reader into a writer.",null,null],[5,"flush","","Creates a future which will entirely flush an I/O object and then yield the object itself.",null,{"inputs":[{"name":"a"}],"output":{"name":"flush"}}],[3,"ReadToEnd","","A future which can be used to easily read the entire contents of a stream into a vector.",null,null],[8,"Codec","","Encoding and decoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",3,null],[16,"Out","","The type of frames to be encoded.",3,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",3,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"result"}}],[11,"decode_eof","","A default method available to be called when there are no more bytes available to be read from the underlying I/O.",3,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"result"}}],[10,"encode","","Encodes a frame into the buffer provided.",3,null],[3,"WriteHalf","","The writable half of an object returned from `Io::split`.",null,null],[5,"copy","","Creates a future which represents copying all the bytes from one object to another.",null,{"inputs":[{"name":"r"},{"name":"w"}],"output":{"name":"copy"}}],[5,"read_to_end","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided.",null,{"inputs":[{"name":"a"},{"name":"vec"}],"output":{"name":"readtoend"}}],[3,"ReadExact","","A future which can be used to easily read exactly enough bytes to fill a buffer.",null,null],[3,"Framed","","A unified `Stream` and `Sink` interface to an underlying `Io` object, using the `Codec` trait to encode and decode frames.",null,null],[5,"write_all","","Creates a future that will write the entire contents of the buffer `buf` to the stream `a` provided.",null,{"inputs":[{"name":"a"},{"name":"t"}],"output":{"name":"writeall"}}],[3,"EasyBufMut","","An RAII object returned from `get_mut` which provides mutable access to the underlying `Vec<u8>`.",null,null],[3,"ReadUntil","","A future which can be used to easily read the contents of a stream into a vector until the delimiter is reached.",null,null],[3,"WriteAll","","A future used to write the entire contents of some data to a stream.",null,null],[3,"ReadHalf","","The readable half of an object returned from `Io::split`.",null,null],[5,"read_until","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided until the delimiter `byte` is reached. This method is the async equivalent to [`BufRead::read_until`].",null,{"inputs":[{"name":"a"},{"name":"u8"},{"name":"vec"}],"output":{"name":"readuntil"}}],[3,"Read","","A future which can be used to easily read available number of bytes to fill a buffer.",null,null],[3,"EasyBuf","","A reference counted buffer of bytes.",null,null],[3,"Flush","","A future used to fully flush an I/O object.",null,null],[3,"Window","","A owned window around an underlying buffer.",null,null],[5,"read_exact","","Creates a future which will read exactly enough bytes to fill `buf`, returning an error if EOF is hit sooner.",null,{"inputs":[{"name":"a"},{"name":"t"}],"output":{"name":"readexact"}}],[0,"net","jsonrpc_http_server::tokio_core","TCP/UDP bindings for `tokio-core`",null,null],[8,"UdpCodec","jsonrpc_http_server::tokio_core::net","Encoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",4,null],[16,"Out","","The type of frames to be encoded.",4,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",4,null],[10,"encode","","Encodes a frame into the buffer provided.",4,null],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",null,null],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",null,null],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",null,null],[3,"UdpSocket","","An I/O object representing a UDP socket.",null,null],[3,"UdpFramed","","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `UdpCodec` trait to encode and decode frames.",null,null],[3,"TcpStreamNew","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",null,null],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",null,null],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",null,null],[0,"reactor","jsonrpc_http_server::tokio_core","The core reactor driving all I/O",null,null],[3,"Core","jsonrpc_http_server::tokio_core::reactor","An event loop.",null,null],[3,"CoreId","","An unique ID for a Core",null,null],[3,"Remote","","Handle to an event loop, used to construct I/O objects, send messages, and otherwise interact indirectly with the event loop itself.",null,null],[3,"Handle","","A non-sendable handle to an event loop, useful for manufacturing instances of `LoopData`.",null,null],[3,"Interval","","A stream representing notifications at fixed interval",null,null],[3,"PollEvented","","A concrete implementation of a stream of readiness notifications for I/O objects that originates from an event loop.",null,null],[3,"Timeout","","A future representing the notification that a timeout has occurred.",null,null],[4,"CorsHeader","jsonrpc_http_server","CORS Header Result.",null,null],[13,"NotRequired","","CORS header was not required. Origin is not present in the request.",5,null],[13,"Invalid","","CORS header is not returned, Origin is not allowed to access the resource.",5,null],[13,"Ok","","CORS header to include in the response. Origin is allowed to access the resource.",5,null],[3,"ServerHandler","","jsonrpc http request handler.",null,null],[3,"Response","","Simple server response structure",null,null],[12,"code","","Response code",6,null],[12,"content_type","","Response content type",6,null],[12,"content","","Response body",6,null],[3,"Rpc","","RPC Handler bundled with metadata extractor.",null,null],[12,"handler","","RPC Handler",7,null],[12,"extractor","","Metadata extractor",7,null],[3,"ServerBuilder","","Convenient JSON-RPC HTTP Server builder.",null,null],[3,"Server","","jsonrpc http server instance",null,null],[4,"Error","","RPC Server startup error.",null,null],[13,"Io","","IO Error",8,null],[13,"Other","","Other Error (hyper)",8,null],[4,"RequestMiddlewareAction","","Action undertaken by a middleware.",null,null],[13,"Proceed","","Proceed with standard RPC handling",9,null],[12,"should_continue_on_invalid_cors","jsonrpc_http_server::RequestMiddlewareAction","Should the request be processed even if invalid CORS headers are detected? This allows for side effects to take place.",9,null],[13,"Respond","jsonrpc_http_server","Intercept the request and respond differently.",9,null],[12,"should_validate_hosts","jsonrpc_http_server::RequestMiddlewareAction","Should standard hosts validation be performed?",9,null],[12,"handler","","hyper handler used to process the request",9,null],[5,"is_host_allowed","jsonrpc_http_server","Returns `true` if Host header in request matches a list of allowed hosts.",null,{"inputs":[{"name":"request"},{"name":"option"}],"output":{"name":"bool"}}],[5,"cors_header","","Returns a CORS header that should be returned with that request.",null,{"inputs":[{"name":"request"},{"name":"option"}],"output":{"name":"corsheader"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Create a response with empty body and 200 OK status code.",6,{"inputs":[],"output":{"name":"self"}}],[11,"ok","","Create a response with given body and 200 OK status code.",6,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"internal_error","","Create a response for internal error.",6,{"inputs":[],"output":{"name":"self"}}],[11,"host_not_allowed","","Create a response for not allowed hosts.",6,{"inputs":[],"output":{"name":"self"}}],[11,"unsupported_content_type","","Create a response for unsupported content type.",6,{"inputs":[],"output":{"name":"self"}}],[11,"method_not_allowed","","Create a response for disallowed method used.",6,{"inputs":[],"output":{"name":"self"}}],[11,"invalid_cors","","CORS invalid",6,{"inputs":[],"output":{"name":"self"}}],[11,"into","","",6,{"inputs":[{"name":"self"}],"output":{"name":"response"}}],[11,"new","","Create new request handler.",10,{"inputs":[{"name":"rpc"},{"name":"option"},{"name":"option"},{"name":"arc"}],"output":{"name":"self"}}],[11,"call","","",10,null],[6,"ServerResult","","Result of starting the Server.",null,null],[8,"RequestMiddleware","","Allows to intercept request and handle it differently.",null,null],[10,"on_request","","Takes a request and decides how to proceed with it.",11,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"requestmiddlewareaction"}}],[8,"MetaExtractor","","Extracts metadata from the HTTP request.",null,null],[11,"read_metadata","","Read the metadata from the request",12,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"m"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",8,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",8,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",8,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",8,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"from","","",9,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"from","","",9,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"new","","Creates new `ServerBuilder` for given `IoHandler`.",13,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"event_loop_remote","","Utilize existing event loop remote to poll RPC results. Applies only to 1 of the threads. Other threads will spawn their own Event Loops.",13,{"inputs":[{"name":"self"},{"name":"remote"}],"output":{"name":"self"}}],[11,"threads","","Sets number of threads of the server to run. Panics when set to `0`.",13,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"cors","","Configures a list of allowed CORS origins.",13,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"self"}}],[11,"request_middleware","","Configures request middleware",13,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"meta_extractor","","Configures metadata extractor",13,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"allow_only_bind_host","","Allow connections only with `Host` header set to binding address.",13,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"allowed_hosts","","Specify a list of valid `Host` headers. Binding address is allowed automatically.",13,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"self"}}],[11,"start_http","","Start this JSON-RPC HTTP server trying to bind to specified `SocketAddr`.",13,{"inputs":[{"name":"self"},{"name":"socketaddr"}],"output":{"name":"serverresult"}}],[11,"address","","Returns address of this server",14,{"inputs":[{"name":"self"}],"output":{"name":"socketaddr"}}],[11,"close","","Closes the server.",14,{"inputs":[{"name":"self"}],"output":null}],[11,"wait","","Will block, waiting for the server to finish.",14,{"inputs":[{"name":"self"}],"output":null}],[11,"drop","","",14,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Creates a new `Host` given hostname and port number.",15,{"inputs":[{"name":"str"},{"name":"t"}],"output":{"name":"host"}}],[11,"parse","","Attempts to parse given string as a `Host`. NOTE: This method always succeeds and falls back to sensible defaults.",15,{"inputs":[{"name":"str"}],"output":{"name":"host"}}],[11,"into","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"into","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"hash","","",15,null],[11,"deref","","",16,null],[11,"deref","","",15,null],[11,"matches","","",16,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"matches","","",15,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"origin"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"accesscontrolalloworigin"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"corsheader"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"host"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"domainsvalidation"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"origin"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"origin"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"accesscontrolalloworigin"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"accesscontrolalloworigin"}],"output":{"name":"bool"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"corsheader"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"corsheader"}],"output":{"name":"bool"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"host"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"host"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"bool"}}],[11,"from","","",16,{"inputs":[{"name":"t"}],"output":{"name":"origin"}}],[11,"from","","",1,{"inputs":[{"name":"t"}],"output":{"name":"accesscontrolalloworigin"}}],[11,"from","","",15,{"inputs":[{"name":"t"}],"output":{"name":"host"}}],[11,"from","","",0,{"inputs":[{"name":"option"}],"output":{"name":"domainsvalidation"}}],[11,"into","jsonrpc_http_server::tokio_core::io","",17,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash","","",17,null],[11,"hash","jsonrpc_http_server::tokio_core::reactor","",18,null],[11,"deref","jsonrpc_http_server::tokio_core::io","",19,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"start_send","","",20,null],[11,"poll_complete","","",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"start_send","jsonrpc_http_server::tokio_core::net","",21,null],[11,"poll_complete","","",21,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","",21,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"as_raw_fd","","",22,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"as_raw_fd","","",23,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"as_raw_fd","","",24,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"poll","jsonrpc_http_server::tokio_core::io","",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::net","",25,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",21,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::reactor","",26,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll_read","jsonrpc_http_server::tokio_core::net","",22,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","",22,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"read_vec","","",22,null],[11,"write_vec","","",22,null],[11,"poll_read","jsonrpc_http_server::tokio_core::reactor","",27,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","",27,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"partial_cmp","jsonrpc_http_server::tokio_core::io","",17,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_http_server::tokio_core::net","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_http_server::tokio_core::reactor","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::io","",31,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",32,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",33,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",34,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",35,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",36,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::net","",38,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",39,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",40,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::reactor","",41,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read","jsonrpc_http_server::tokio_core::io","",42,null],[11,"read","jsonrpc_http_server::tokio_core::net","",22,null],[11,"read","jsonrpc_http_server::tokio_core::reactor","",27,null],[11,"write","jsonrpc_http_server::tokio_core::io","",43,null],[11,"flush","","",43,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","jsonrpc_http_server::tokio_core::net","",22,null],[11,"flush","","",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","jsonrpc_http_server::tokio_core::reactor","",27,null],[11,"flush","","",27,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"deref_mut","jsonrpc_http_server::tokio_core::io","",19,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"shutdown","jsonrpc_http_server::tokio_core::net","",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write_buf","","",22,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[11,"shutdown","jsonrpc_http_server::tokio_core::reactor","",27,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"drop","jsonrpc_http_server::tokio_core::io","",19,null],[11,"drop","jsonrpc_http_server::tokio_core::reactor","",27,null],[11,"drop","","",41,null],[11,"drop","","",26,null],[11,"as_mut","jsonrpc_http_server::tokio_core::io","",44,null],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"easybuf"}}],[11,"clone","jsonrpc_http_server::tokio_core::reactor","",18,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"as_ref","jsonrpc_http_server::tokio_core::io","",17,null],[11,"as_ref","","",44,null],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"eq","jsonrpc_http_server::tokio_core::reactor","",18,{"inputs":[{"name":"self"},{"name":"coreid"}],"output":{"name":"bool"}}],[11,"ne","","",18,{"inputs":[{"name":"self"},{"name":"coreid"}],"output":{"name":"bool"}}],[11,"cmp","jsonrpc_http_server::tokio_core::io","",17,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"ordering"}}],[11,"from","","",17,{"inputs":[{"name":"vec"}],"output":{"name":"easybuf"}}],[11,"prepare_uninitialized_buffer","jsonrpc_http_server::tokio_core::net","",22,null],[11,"read_buf","","",22,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[11,"new","jsonrpc_http_server","Creates new origin given protocol, hostname and port parts. Pre-processes input data if necessary.",16,{"inputs":[{"name":"originprotocol"},{"name":"str"},{"name":"t"}],"output":{"name":"origin"}}],[11,"parse","","Attempts to parse given string as a `Origin`. NOTE: This method always succeeds and falls back to sensible defaults.",16,{"inputs":[{"name":"str"}],"output":{"name":"origin"}}],[11,"poll_write","jsonrpc_http_server::tokio_core::io","Calls the underlying `poll_write` function on this handling, testing to see if it's ready to be written to.",43,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",20,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",20,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",20,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"poll_read","","Calls the underlying `poll_read` function on this handling, testing to see if it's ready to be read from.",42,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"new","","Creates a new EasyBuf with no data and the default capacity.",17,{"inputs":[],"output":{"name":"easybuf"}}],[11,"with_capacity","","Creates a new EasyBuf with `cap` capacity.",17,{"inputs":[{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"len","","Returns the number of bytes contained in this `EasyBuf`.",17,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"as_slice","","Returns the inner contents of this `EasyBuf` as a slice.",17,null],[11,"split_off","","Splits the buffer into two at the given index.",17,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"drain_to","","Splits the buffer into two at the given index.",17,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"get_mut","","Returns a mutable reference to the underlying growable buffer of bytes.",17,{"inputs":[{"name":"self"}],"output":{"name":"easybufmut"}}],[11,"new","","Creates a new window around the buffer `t` defaulting to the entire slice.",44,{"inputs":[{"name":"t"}],"output":{"name":"window"}}],[11,"get_ref","","Gets a shared reference to the underlying buffer inside of this `Window`.",44,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Gets a mutable reference to the underlying buffer inside of this `Window`.",44,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_inner","","Consumes this `Window`, returning the underlying buffer.",44,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"start","","Returns the starting index of this window into the underlying buffer `T`.",44,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"end","","Returns the end index of this window into the underlying buffer `T`.",44,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"set_start","","Changes the starting index of this window to the index specified.",44,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"window"}}],[11,"set_end","","Changes the end index of this window to the index specified.",44,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"window"}}],[11,"connect","jsonrpc_http_server::tokio_core::net","Create a new TCP stream connected to the specified address.",22,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"tcpstreamnew"}}],[11,"from_stream","","Create a new `TcpStream` from a `net::TcpStream`.",22,{"inputs":[{"name":"tcpstream"},{"name":"handle"}],"output":{"name":"result"}}],[11,"connect_stream","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",22,{"inputs":[{"name":"tcpstream"},{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"box"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",22,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",22,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"peer_addr","","Returns the remote address that this stream is connected to.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",22,{"inputs":[{"name":"self"},{"name":"shutdown"}],"output":{"name":"result"}}],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",22,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_keepalive_ms","","Sets whether keepalive messages are enabled to be sent on this socket.",22,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"keepalive_ms","","Returns whether keepalive messages are enabled on this socket, and if so the amount of milliseconds between them.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",22,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Create a new TCP listener associated with this event loop.",23,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_listener","","Create a new TCP listener from the standard library's TCP listener.",23,{"inputs":[{"name":"tcplistener"},{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",23,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"local_addr","","Returns the local address that this listener is bound to.",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",23,{"inputs":[{"name":"self"}],"output":{"name":"incoming"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",23,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",23,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Create a new UDP socket bound to the specified address.",24,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"from_socket","","Creates a new `UdpSocket` from the previously bound socket provided.",24,{"inputs":[{"name":"udpsocket"},{"name":"handle"}],"output":{"name":"result"}}],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `UdpSocket` object, using the provided `UdpCodec` to read and write the raw data.",24,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"udpframed"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",24,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",24,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",24,null],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",24,{"inputs":[{"name":"self"},{"name":"t"},{"name":"socketaddr"}],"output":{"name":"senddgram"}}],[11,"recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",24,null],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",24,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"recvdgram"}}],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",24,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",24,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",24,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",24,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",24,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",24,{"inputs":[{"name":"self"},{"name":"ipv4addr"},{"name":"ipv4addr"}],"output":{"name":"result"}}],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",24,{"inputs":[{"name":"self"},{"name":"ipv6addr"},{"name":"u32"}],"output":{"name":"result"}}],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",24,{"inputs":[{"name":"self"},{"name":"ipv4addr"},{"name":"ipv4addr"}],"output":{"name":"result"}}],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",24,{"inputs":[{"name":"self"},{"name":"ipv6addr"},{"name":"u32"}],"output":{"name":"result"}}],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",21,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",21,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",21,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"new","jsonrpc_http_server::tokio_core::reactor","Creates a new event loop, returning any error that happened during the creation.",28,{"inputs":[],"output":{"name":"result"}}],[11,"handle","","Returns a handle to this event loop which cannot be sent across threads but can be used as a proxy to the event loop itself.",28,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"remote","","Generates a remote handle to this event loop which can be used to spawn tasks from other threads into this event loop.",28,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"run","","Runs a future until completion, driving the event loop while we're otherwise waiting for the future to complete.",28,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",28,null],[11,"id","","Get the ID of this loop",28,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"spawn","","Spawns a new future into the event loop this remote is associated with.",29,null],[11,"id","","Return the ID of the represented Core",29,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"handle","","Attempts to \"promote\" this remote to a handle, if possible.",29,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"remote","","Returns a reference to the underlying remote handle to the event loop.",30,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"spawn","","Spawns a new future on the event loop this handle is associated with.",30,null],[11,"spawn_fn","","Spawns a closure on this event loop.",30,null],[11,"id","","Return the ID of the represented Core",30,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"new","","Creates a new interval which will fire at `dur` time into the future, and will repeat every `dur` interval after",26,{"inputs":[{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new_at","","Creates a new interval which will fire at the time specified by `at`, and then will repeat every `dur` interval after",26,{"inputs":[{"name":"instant"},{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new","","Creates a new readiness stream associated with the provided `loop_handle` and for the given `source`.",27,{"inputs":[{"name":"e"},{"name":"handle"}],"output":{"name":"result"}}],[11,"deregister","","Deregisters this source of events from the reactor core specified.",27,{"inputs":[{"name":"self"},{"name":"handle"}],"output":{"name":"result"}}],[11,"poll_read","","Tests to see if this source is ready to be read from or not.",27,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Tests to see if this source is ready to be written to or not.",27,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"need_read","","Indicates to this source of events that the corresponding I/O object is no longer readable, but it needs to be.",27,null],[11,"need_write","","Indicates to this source of events that the corresponding I/O object is no longer writable, but it needs to be.",27,null],[11,"remote","","Returns a reference to the event loop handle that this readiness stream is associated with.",27,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",27,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",27,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"new","","Creates a new timeout which will fire at `dur` time into the future.",41,{"inputs":[{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new_at","","Creates a new timeout which will fire at the time specified by `at`.",41,{"inputs":[{"name":"instant"},{"name":"handle"}],"output":{"name":"result"}}],[11,"map","jsonrpc_http_server","Maps `Ok` variant of `CorsHeader`.",5,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"corsheader"}}]],"paths":[[4,"DomainsValidation"],[4,"AccessControlAllowOrigin"],[8,"Io"],[8,"Codec"],[8,"UdpCodec"],[4,"CorsHeader"],[3,"Response"],[3,"Rpc"],[4,"Error"],[4,"RequestMiddlewareAction"],[3,"ServerHandler"],[8,"RequestMiddleware"],[8,"MetaExtractor"],[3,"ServerBuilder"],[3,"Server"],[3,"Host"],[3,"Origin"],[3,"EasyBuf"],[3,"CoreId"],[3,"EasyBufMut"],[3,"Framed"],[3,"UdpFramed"],[3,"TcpStream"],[3,"TcpListener"],[3,"UdpSocket"],[3,"Incoming"],[3,"Interval"],[3,"PollEvented"],[3,"Core"],[3,"Remote"],[3,"Handle"],[3,"Copy"],[3,"Flush"],[3,"ReadExact"],[3,"ReadToEnd"],[3,"Read"],[3,"ReadUntil"],[3,"WriteAll"],[3,"TcpStreamNew"],[3,"SendDgram"],[3,"RecvDgram"],[3,"Timeout"],[3,"ReadHalf"],[3,"WriteHalf"],[3,"Window"]]};
searchIndex["jsonrpc_ipc_server"] = {"doc":"Cross-platform JSON-RPC IPC transport.","items":[[0,"io","jsonrpc_ipc_server::tokio_core","I/O conveniences when working with primitives in `tokio-core`",null,null],[6,"IoFuture","jsonrpc_ipc_server::tokio_core::io","A convenience typedef around a `Future` whose error component is `io::Error`",null,null],[6,"IoStream","","A convenience typedef around a `Stream` whose error component is `io::Error`",null,null],[8,"Io","","A trait for read/write I/O objects",null,null],[11,"poll_read","","Tests to see if this I/O object may be readable.",0,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Tests to see if this I/O object may be writable.",0,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"read_vec","","Read in a list of buffers all at once.",0,null],[11,"write_vec","","Write a list of buffers all at once.",0,null],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",0,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"framed"}}],[11,"split","","Helper method for splitting this read/write object into two halves.",0,null],[5,"read","","Tries to read some bytes directly into the given `buf` in asynchronous manner, returning a future type.",null,{"inputs":[{"name":"r"},{"name":"t"}],"output":{"name":"read"}}],[3,"Copy","","A future which will copy all data from a reader into a writer.",null,null],[5,"flush","","Creates a future which will entirely flush an I/O object and then yield the object itself.",null,{"inputs":[{"name":"a"}],"output":{"name":"flush"}}],[3,"ReadToEnd","","A future which can be used to easily read the entire contents of a stream into a vector.",null,null],[8,"Codec","","Encoding and decoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",1,null],[16,"Out","","The type of frames to be encoded.",1,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",1,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"result"}}],[11,"decode_eof","","A default method available to be called when there are no more bytes available to be read from the underlying I/O.",1,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"result"}}],[10,"encode","","Encodes a frame into the buffer provided.",1,null],[3,"WriteHalf","","The writable half of an object returned from `Io::split`.",null,null],[5,"copy","","Creates a future which represents copying all the bytes from one object to another.",null,{"inputs":[{"name":"r"},{"name":"w"}],"output":{"name":"copy"}}],[5,"read_to_end","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided.",null,{"inputs":[{"name":"a"},{"name":"vec"}],"output":{"name":"readtoend"}}],[3,"ReadExact","","A future which can be used to easily read exactly enough bytes to fill a buffer.",null,null],[3,"Framed","","A unified `Stream` and `Sink` interface to an underlying `Io` object, using the `Codec` trait to encode and decode frames.",null,null],[5,"write_all","","Creates a future that will write the entire contents of the buffer `buf` to the stream `a` provided.",null,{"inputs":[{"name":"a"},{"name":"t"}],"output":{"name":"writeall"}}],[3,"EasyBufMut","","An RAII object returned from `get_mut` which provides mutable access to the underlying `Vec<u8>`.",null,null],[3,"ReadUntil","","A future which can be used to easily read the contents of a stream into a vector until the delimiter is reached.",null,null],[3,"WriteAll","","A future used to write the entire contents of some data to a stream.",null,null],[3,"ReadHalf","","The readable half of an object returned from `Io::split`.",null,null],[5,"read_until","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided until the delimiter `byte` is reached. This method is the async equivalent to [`BufRead::read_until`].",null,{"inputs":[{"name":"a"},{"name":"u8"},{"name":"vec"}],"output":{"name":"readuntil"}}],[3,"Read","","A future which can be used to easily read available number of bytes to fill a buffer.",null,null],[3,"EasyBuf","","A reference counted buffer of bytes.",null,null],[3,"Flush","","A future used to fully flush an I/O object.",null,null],[3,"Window","","A owned window around an underlying buffer.",null,null],[5,"read_exact","","Creates a future which will read exactly enough bytes to fill `buf`, returning an error if EOF is hit sooner.",null,{"inputs":[{"name":"a"},{"name":"t"}],"output":{"name":"readexact"}}],[0,"net","jsonrpc_ipc_server::tokio_core","TCP/UDP bindings for `tokio-core`",null,null],[8,"UdpCodec","jsonrpc_ipc_server::tokio_core::net","Encoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",2,null],[16,"Out","","The type of frames to be encoded.",2,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",2,null],[10,"encode","","Encodes a frame into the buffer provided.",2,null],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",null,null],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",null,null],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",null,null],[3,"UdpSocket","","An I/O object representing a UDP socket.",null,null],[3,"UdpFramed","","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `UdpCodec` trait to encode and decode frames.",null,null],[3,"TcpStreamNew","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",null,null],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",null,null],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",null,null],[0,"reactor","jsonrpc_ipc_server::tokio_core","The core reactor driving all I/O",null,null],[3,"Core","jsonrpc_ipc_server::tokio_core::reactor","An event loop.",null,null],[3,"CoreId","","An unique ID for a Core",null,null],[3,"Remote","","Handle to an event loop, used to construct I/O objects, send messages, and otherwise interact indirectly with the event loop itself.",null,null],[3,"Handle","","A non-sendable handle to an event loop, useful for manufacturing instances of `LoopData`.",null,null],[3,"Interval","","A stream representing notifications at fixed interval",null,null],[3,"PollEvented","","A concrete implementation of a stream of readiness notifications for I/O objects that originates from an event loop.",null,null],[3,"Timeout","","A future representing the notification that a timeout has occurred.",null,null],[3,"RequestContext","jsonrpc_ipc_server","Request context",null,null],[12,"endpoint_addr","","Remote UDS endpoint",3,null],[3,"Server","","IPC Server handle",null,null],[3,"ServerBuilder","","IPC server builder",null,null],[11,"new","","",4,{"inputs":[{"name":"t"}],"output":{"name":"serverbuilder"}}],[11,"event_loop_remote","","Sets shared different event loop remote.",4,{"inputs":[{"name":"self"},{"name":"remote"}],"output":{"name":"self"}}],[11,"session_metadata_extractor","","Sets session metadata extractor.",4,{"inputs":[{"name":"self"},{"name":"x"}],"output":{"name":"self"}}],[11,"start","","Run server (in a separate thread)",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"close","","Closes the server (waits for finish)",5,{"inputs":[{"name":"self"}],"output":null}],[11,"wait","","Wait for the server to finish",5,{"inputs":[{"name":"self"}],"output":null}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[8,"MetaExtractor","","Metadata extractor (per session)",null,null],[10,"extract","","Extracts metadata from request context",6,{"inputs":[{"name":"self"},{"name":"requestcontext"}],"output":{"name":"m"}}],[11,"into","jsonrpc_ipc_server::tokio_core::io","",7,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash","","",7,null],[11,"hash","jsonrpc_ipc_server::tokio_core::reactor","",8,null],[11,"deref","jsonrpc_ipc_server::tokio_core::io","",9,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"start_send","","",10,null],[11,"poll_complete","","",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"start_send","jsonrpc_ipc_server::tokio_core::net","",11,null],[11,"poll_complete","","",11,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","",11,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"as_raw_fd","","",12,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"as_raw_fd","","",13,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"as_raw_fd","","",14,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::io","",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::net","",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",11,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::reactor","",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll_read","jsonrpc_ipc_server::tokio_core::net","",12,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","",12,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"read_vec","","",12,null],[11,"write_vec","","",12,null],[11,"poll_read","jsonrpc_ipc_server::tokio_core::reactor","",17,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","",17,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"partial_cmp","jsonrpc_ipc_server::tokio_core::io","",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_ipc_server::tokio_core::net","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_ipc_server::tokio_core::reactor","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::io","",21,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",25,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",26,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",27,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::net","",28,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",29,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",30,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::reactor","",31,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read","jsonrpc_ipc_server::tokio_core::io","",32,null],[11,"read","jsonrpc_ipc_server::tokio_core::net","",12,null],[11,"read","jsonrpc_ipc_server::tokio_core::reactor","",17,null],[11,"write","jsonrpc_ipc_server::tokio_core::io","",33,null],[11,"flush","","",33,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","jsonrpc_ipc_server::tokio_core::net","",12,null],[11,"flush","","",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","jsonrpc_ipc_server::tokio_core::reactor","",17,null],[11,"flush","","",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"deref_mut","jsonrpc_ipc_server::tokio_core::io","",9,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"shutdown","jsonrpc_ipc_server::tokio_core::net","",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write_buf","","",12,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[11,"shutdown","jsonrpc_ipc_server::tokio_core::reactor","",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"drop","jsonrpc_ipc_server::tokio_core::io","",9,null],[11,"drop","jsonrpc_ipc_server::tokio_core::reactor","",17,null],[11,"drop","","",31,null],[11,"drop","","",16,null],[11,"as_mut","jsonrpc_ipc_server::tokio_core::io","",34,null],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"easybuf"}}],[11,"clone","jsonrpc_ipc_server::tokio_core::reactor","",8,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"as_ref","jsonrpc_ipc_server::tokio_core::io","",7,null],[11,"as_ref","","",34,null],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"eq","jsonrpc_ipc_server::tokio_core::reactor","",8,{"inputs":[{"name":"self"},{"name":"coreid"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"coreid"}],"output":{"name":"bool"}}],[11,"cmp","jsonrpc_ipc_server::tokio_core::io","",7,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"ordering"}}],[11,"from","","",7,{"inputs":[{"name":"vec"}],"output":{"name":"easybuf"}}],[11,"prepare_uninitialized_buffer","jsonrpc_ipc_server::tokio_core::net","",12,null],[11,"read_buf","","",12,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[11,"poll_write","jsonrpc_ipc_server::tokio_core::io","Calls the underlying `poll_write` function on this handling, testing to see if it's ready to be written to.",33,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",10,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",10,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",10,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"poll_read","","Calls the underlying `poll_read` function on this handling, testing to see if it's ready to be read from.",32,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"new","","Creates a new EasyBuf with no data and the default capacity.",7,{"inputs":[],"output":{"name":"easybuf"}}],[11,"with_capacity","","Creates a new EasyBuf with `cap` capacity.",7,{"inputs":[{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"len","","Returns the number of bytes contained in this `EasyBuf`.",7,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"as_slice","","Returns the inner contents of this `EasyBuf` as a slice.",7,null],[11,"split_off","","Splits the buffer into two at the given index.",7,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"drain_to","","Splits the buffer into two at the given index.",7,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"get_mut","","Returns a mutable reference to the underlying growable buffer of bytes.",7,{"inputs":[{"name":"self"}],"output":{"name":"easybufmut"}}],[11,"new","","Creates a new window around the buffer `t` defaulting to the entire slice.",34,{"inputs":[{"name":"t"}],"output":{"name":"window"}}],[11,"get_ref","","Gets a shared reference to the underlying buffer inside of this `Window`.",34,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Gets a mutable reference to the underlying buffer inside of this `Window`.",34,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_inner","","Consumes this `Window`, returning the underlying buffer.",34,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"start","","Returns the starting index of this window into the underlying buffer `T`.",34,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"end","","Returns the end index of this window into the underlying buffer `T`.",34,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"set_start","","Changes the starting index of this window to the index specified.",34,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"window"}}],[11,"set_end","","Changes the end index of this window to the index specified.",34,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"window"}}],[11,"connect","jsonrpc_ipc_server::tokio_core::net","Create a new TCP stream connected to the specified address.",12,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"tcpstreamnew"}}],[11,"from_stream","","Create a new `TcpStream` from a `net::TcpStream`.",12,{"inputs":[{"name":"tcpstream"},{"name":"handle"}],"output":{"name":"result"}}],[11,"connect_stream","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",12,{"inputs":[{"name":"tcpstream"},{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"box"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",12,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",12,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"peer_addr","","Returns the remote address that this stream is connected to.",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",12,{"inputs":[{"name":"self"},{"name":"shutdown"}],"output":{"name":"result"}}],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",12,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_keepalive_ms","","Sets whether keepalive messages are enabled to be sent on this socket.",12,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"keepalive_ms","","Returns whether keepalive messages are enabled on this socket, and if so the amount of milliseconds between them.",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",12,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Create a new TCP listener associated with this event loop.",13,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_listener","","Create a new TCP listener from the standard library's TCP listener.",13,{"inputs":[{"name":"tcplistener"},{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",13,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"local_addr","","Returns the local address that this listener is bound to.",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",13,{"inputs":[{"name":"self"}],"output":{"name":"incoming"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",13,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",13,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Create a new UDP socket bound to the specified address.",14,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"from_socket","","Creates a new `UdpSocket` from the previously bound socket provided.",14,{"inputs":[{"name":"udpsocket"},{"name":"handle"}],"output":{"name":"result"}}],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `UdpSocket` object, using the provided `UdpCodec` to read and write the raw data.",14,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"udpframed"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",14,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",14,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",14,null],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",14,{"inputs":[{"name":"self"},{"name":"t"},{"name":"socketaddr"}],"output":{"name":"senddgram"}}],[11,"recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",14,null],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",14,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"recvdgram"}}],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",14,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",14,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",14,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",14,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",14,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",14,{"inputs":[{"name":"self"},{"name":"ipv4addr"},{"name":"ipv4addr"}],"output":{"name":"result"}}],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",14,{"inputs":[{"name":"self"},{"name":"ipv6addr"},{"name":"u32"}],"output":{"name":"result"}}],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",14,{"inputs":[{"name":"self"},{"name":"ipv4addr"},{"name":"ipv4addr"}],"output":{"name":"result"}}],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",14,{"inputs":[{"name":"self"},{"name":"ipv6addr"},{"name":"u32"}],"output":{"name":"result"}}],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",11,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",11,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",11,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"new","jsonrpc_ipc_server::tokio_core::reactor","Creates a new event loop, returning any error that happened during the creation.",18,{"inputs":[],"output":{"name":"result"}}],[11,"handle","","Returns a handle to this event loop which cannot be sent across threads but can be used as a proxy to the event loop itself.",18,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"remote","","Generates a remote handle to this event loop which can be used to spawn tasks from other threads into this event loop.",18,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"run","","Runs a future until completion, driving the event loop while we're otherwise waiting for the future to complete.",18,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",18,null],[11,"id","","Get the ID of this loop",18,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"spawn","","Spawns a new future into the event loop this remote is associated with.",19,null],[11,"id","","Return the ID of the represented Core",19,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"handle","","Attempts to \"promote\" this remote to a handle, if possible.",19,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"remote","","Returns a reference to the underlying remote handle to the event loop.",20,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"spawn","","Spawns a new future on the event loop this handle is associated with.",20,null],[11,"spawn_fn","","Spawns a closure on this event loop.",20,null],[11,"id","","Return the ID of the represented Core",20,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"new","","Creates a new interval which will fire at `dur` time into the future, and will repeat every `dur` interval after",16,{"inputs":[{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new_at","","Creates a new interval which will fire at the time specified by `at`, and then will repeat every `dur` interval after",16,{"inputs":[{"name":"instant"},{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new","","Creates a new readiness stream associated with the provided `loop_handle` and for the given `source`.",17,{"inputs":[{"name":"e"},{"name":"handle"}],"output":{"name":"result"}}],[11,"deregister","","Deregisters this source of events from the reactor core specified.",17,{"inputs":[{"name":"self"},{"name":"handle"}],"output":{"name":"result"}}],[11,"poll_read","","Tests to see if this source is ready to be read from or not.",17,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Tests to see if this source is ready to be written to or not.",17,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"need_read","","Indicates to this source of events that the corresponding I/O object is no longer readable, but it needs to be.",17,null],[11,"need_write","","Indicates to this source of events that the corresponding I/O object is no longer writable, but it needs to be.",17,null],[11,"remote","","Returns a reference to the event loop handle that this readiness stream is associated with.",17,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",17,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",17,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"new","","Creates a new timeout which will fire at `dur` time into the future.",31,{"inputs":[{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new_at","","Creates a new timeout which will fire at the time specified by `at`.",31,{"inputs":[{"name":"instant"},{"name":"handle"}],"output":{"name":"result"}}]],"paths":[[8,"Io"],[8,"Codec"],[8,"UdpCodec"],[3,"RequestContext"],[3,"ServerBuilder"],[3,"Server"],[8,"MetaExtractor"],[3,"EasyBuf"],[3,"CoreId"],[3,"EasyBufMut"],[3,"Framed"],[3,"UdpFramed"],[3,"TcpStream"],[3,"TcpListener"],[3,"UdpSocket"],[3,"Incoming"],[3,"Interval"],[3,"PollEvented"],[3,"Core"],[3,"Remote"],[3,"Handle"],[3,"Copy"],[3,"Flush"],[3,"ReadExact"],[3,"ReadToEnd"],[3,"Read"],[3,"ReadUntil"],[3,"WriteAll"],[3,"TcpStreamNew"],[3,"SendDgram"],[3,"RecvDgram"],[3,"Timeout"],[3,"ReadHalf"],[3,"WriteHalf"],[3,"Window"]]};
searchIndex["jsonrpc_macros"] = {"doc":"High level, typed wrapper for `jsonrpc_core`.","items":[[3,"Trailing","jsonrpc_macros","A wrapper type without an implementation of `Deserialize` which allows a special implementation of `Wrap` for functions that take a trailing default parameter.",null,null],[12,"0","","",0,null],[3,"IoDelegate","","A set of RPC methods and notifications tied to single `delegate` struct.",null,null],[5,"to_value","","Converts a serializable value into `Value`.",null,{"inputs":[{"name":"t"}],"output":{"name":"value"}}],[11,"new","","Creates new `IoDelegate`",1,{"inputs":[{"name":"arc"}],"output":{"name":"self"}}],[11,"add_alias","","Adds an alias to existing method. NOTE: Aliases are not transitive, i.e. you cannot create alias to an alias.",1,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"}],"output":null}],[11,"add_method","","Adds sync method to the delegate.",1,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"add_async_method","","Adds async method to the delegate.",1,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"add_method_with_meta","","Adds async method with metadata to the delegate.",1,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"add_notification","","Adds notification to the delegate.",1,{"inputs":[{"name":"self"},{"name":"str"},{"name":"f"}],"output":null}],[11,"add_subscription","","Adds subscription to the delegate.",1,null],[11,"into","","",1,{"inputs":[{"name":"self"}],"output":{"name":"hashmap"}}],[0,"pubsub","","PUB-SUB auto-serializing structures.",null,null],[4,"SubscriptionId","jsonrpc_macros::pubsub","Unique subscription id. NOTE Assigning same id to different requests will cause the previous request to be unsubscribed.",null,null],[13,"Number","","U64 number",2,null],[13,"String","","String",2,null],[3,"Subscriber","","New PUB-SUB subcriber.",null,null],[3,"Sink","","Subscriber sink.",null,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Wrap non-typed subscriber.",3,{"inputs":[{"name":"subscriber"}],"output":{"name":"self"}}],[11,"reject","","Reject subscription with given error.",3,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"result"}}],[11,"assign_id","","Assign id to this subscriber. This method consumes `Subscriber` and returns `Sink` if the connection is still open or error otherwise.",3,{"inputs":[{"name":"self"},{"name":"subscriptionid"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"sink"}}],[11,"notify","","Sends a notification to the subscriber.",4,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"sinkresult"}}],[11,"start_send","","",4,null],[11,"poll_complete","","",4,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"close","","",4,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[14,"metadata","jsonrpc_macros","Auto-generates an RPC trait from trait definition.",null,null],[14,"build_rpc_trait","","",null,null],[11,"parse_value","jsonrpc_macros::pubsub","Parses `core::Value` into unique subscription id.",2,{"inputs":[{"name":"value"}],"output":{"name":"option"}}],[11,"hash","","",2,null],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"subscriptionid"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"subscriptionid"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"subscriptionid"}],"output":{"name":"bool"}}]],"paths":[[3,"Trailing"],[3,"IoDelegate"],[4,"SubscriptionId"],[3,"Subscriber"],[3,"Sink"]]};
searchIndex["jsonrpc_minihttp_server"] = {"doc":"jsonrpc http server.","items":[[0,"cors","jsonrpc_minihttp_server","CORS handling utility functions",null,null],[4,"OriginProtocol","jsonrpc_minihttp_server::cors","Origin Protocol",null,null],[13,"Http","","Http protocol",0,null],[13,"Https","","Https protocol",0,null],[13,"Custom","","Custom protocol",0,null],[3,"Origin","","Request Origin",null,null],[4,"AccessControlAllowOrigin","","Origins allowed to access",null,null],[13,"Value","","Specific hostname",1,null],[13,"Null","","null-origin (file:///, sandboxed iframe)",1,null],[13,"Any","","Any non-null origin",1,null],[4,"CorsHeader","","CORS Header Result.",null,null],[13,"NotRequired","","CORS header was not required. Origin is not present in the request.",2,null],[13,"Invalid","","CORS header is not returned, Origin is not allowed to access the resource.",2,null],[13,"Ok","","CORS header to include in the response. Origin is allowed to access the resource.",2,null],[5,"get_cors_header","","Returns correct CORS header (if any) given list of allowed origins and current origin.",null,{"inputs":[{"name":"option"},{"name":"option"},{"name":"option"}],"output":{"name":"corsheader"}}],[3,"Host","jsonrpc_minihttp_server","Host type",null,null],[4,"DomainsValidation","","Specifies if domains should be validated.",null,null],[13,"AllowOnly","","Allow only domains on the list.",3,null],[13,"Disabled","","Disable domains validation completely.",3,null],[3,"Req","","Request",null,null],[3,"ServerBuilder","","Convenient JSON-RPC HTTP Server builder.",null,null],[3,"RpcService","","Tokio-proto JSON-RPC HTTP Service",null,null],[3,"RpcResponse","","RPC response wrapper",null,null],[3,"Server","","jsonrpc http server instance",null,null],[4,"Error","","RPC Server startup error.",null,null],[13,"Io","","IO Error",4,null],[11,"new","","Creates new `Req` object",5,{"inputs":[{"name":"request"}],"output":{"name":"self"}}],[11,"method","","Returns request method",5,{"inputs":[{"name":"self"}],"output":{"name":"method"}}],[11,"header","","Returns value of first header with given name. `None` if header is not found or value is not utf-8 encoded",5,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"body","","Returns body of the request as a string",5,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[6,"ServerResult","","Result of starting the Server.",null,null],[8,"MetaExtractor","","Extracts metadata from the HTTP request.",null,null],[11,"read_metadata","","Read the metadata from the request",6,{"inputs":[{"name":"self"},{"name":"req"}],"output":{"name":"m"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",4,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Creates new `ServerBuilder` for given `IoHandler`.",7,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"threads","","Sets number of threads of the server to run. (not available for windows) Panics when set to `0`.",7,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"cors","","Configures a list of allowed CORS origins.",7,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"self"}}],[11,"meta_extractor","","Configures metadata extractor",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"allow_only_bind_host","","Allow connections only with `Host` header set to binding address.",7,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"allowed_hosts","","Specify a list of valid `Host` headers. Binding address is allowed automatically.",7,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"self"}}],[11,"start_http","","Start this JSON-RPC HTTP server trying to bind to specified `SocketAddr`.",7,{"inputs":[{"name":"self"},{"name":"socketaddr"}],"output":{"name":"serverresult"}}],[11,"call","","",8,null],[11,"poll","","",9,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"address","","Returns addresses of this server",10,{"inputs":[{"name":"self"}],"output":{"name":"socketaddr"}}],[11,"close","","Closes the server.",10,{"inputs":[{"name":"self"}],"output":null}],[11,"wait","","Will block, waiting for the server to finish.",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"drop","","",10,{"inputs":[{"name":"self"}],"output":null}],[11,"into","jsonrpc_minihttp_server::cors","",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"into","jsonrpc_minihttp_server","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"hash","jsonrpc_minihttp_server::cors","",0,null],[11,"hash","jsonrpc_minihttp_server","",11,null],[11,"deref","jsonrpc_minihttp_server::cors","",12,null],[11,"deref","jsonrpc_minihttp_server","",11,null],[11,"matches","jsonrpc_minihttp_server::cors","",12,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"matches","jsonrpc_minihttp_server","",11,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"fmt","jsonrpc_minihttp_server::cors","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_minihttp_server","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_minihttp_server::cors","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"originprotocol"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"origin"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"accesscontrolalloworigin"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"corsheader"}}],[11,"clone","jsonrpc_minihttp_server","",11,{"inputs":[{"name":"self"}],"output":{"name":"host"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"domainsvalidation"}}],[11,"eq","jsonrpc_minihttp_server::cors","",0,{"inputs":[{"name":"self"},{"name":"originprotocol"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"originprotocol"}],"output":{"name":"bool"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"origin"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"origin"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"accesscontrolalloworigin"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"accesscontrolalloworigin"}],"output":{"name":"bool"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"corsheader"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"corsheader"}],"output":{"name":"bool"}}],[11,"eq","jsonrpc_minihttp_server","",11,{"inputs":[{"name":"self"},{"name":"host"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"host"}],"output":{"name":"bool"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"bool"}}],[11,"from","jsonrpc_minihttp_server::cors","",12,{"inputs":[{"name":"t"}],"output":{"name":"origin"}}],[11,"from","","",1,{"inputs":[{"name":"t"}],"output":{"name":"accesscontrolalloworigin"}}],[11,"from","jsonrpc_minihttp_server","",11,{"inputs":[{"name":"t"}],"output":{"name":"host"}}],[11,"from","","",3,{"inputs":[{"name":"option"}],"output":{"name":"domainsvalidation"}}],[11,"new","jsonrpc_minihttp_server::cors","Creates new origin given protocol, hostname and port parts. Pre-processes input data if necessary.",12,{"inputs":[{"name":"originprotocol"},{"name":"str"},{"name":"t"}],"output":{"name":"origin"}}],[11,"parse","","Attempts to parse given string as a `Origin`. NOTE: This method always succeeds and falls back to sensible defaults.",12,{"inputs":[{"name":"str"}],"output":{"name":"origin"}}],[11,"map","","Maps `Ok` variant of `CorsHeader`.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"corsheader"}}],[11,"new","jsonrpc_minihttp_server","Creates a new `Host` given hostname and port number.",11,{"inputs":[{"name":"str"},{"name":"t"}],"output":{"name":"host"}}],[11,"parse","","Attempts to parse given string as a `Host`. NOTE: This method always succeeds and falls back to sensible defaults.",11,{"inputs":[{"name":"str"}],"output":{"name":"host"}}]],"paths":[[4,"OriginProtocol"],[4,"AccessControlAllowOrigin"],[4,"CorsHeader"],[4,"DomainsValidation"],[4,"Error"],[3,"Req"],[8,"MetaExtractor"],[3,"ServerBuilder"],[3,"RpcService"],[3,"RpcResponse"],[3,"Server"],[3,"Host"],[3,"Origin"]]};
searchIndex["jsonrpc_pubsub"] = {"doc":"Publish-Subscribe extension for JSON-RPC","items":[[3,"PubSubHandler","jsonrpc_pubsub","Publish-Subscribe extension of `IoHandler`.",null,null],[3,"Session","","RPC client session Keeps track of active subscriptions and unsubscribes from them upon dropping.",null,null],[3,"Sink","","A handle to send notifications directly to subscribed client.",null,null],[3,"Subscriber","","Represents a subscribing client. Subscription handlers can either reject this subscription request or assign an unique id.",null,null],[4,"SubscriptionId","","Unique subscription id. NOTE Assigning same id to different requests will cause the previous request to be unsubscribed.",null,null],[13,"Number","","U64 number",0,null],[13,"String","","String",0,null],[5,"new_subscription","","Creates new subscribe and unsubscribe RPC methods",null,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Creates new `PubSubHandler`",1,{"inputs":[{"name":"metaiohandler"}],"output":{"name":"self"}}],[11,"add_subscription","","Adds new subscription.",1,null],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"into","","",1,{"inputs":[{"name":"self"}],"output":{"name":"metaiohandler"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates new session given transport raw send capabilities. Session should be created as part of metadata, `sender` should be returned by transport.",2,{"inputs":[{"name":"sender"}],"output":{"name":"self"}}],[11,"sender","","Returns transport write stream",2,{"inputs":[{"name":"self"}],"output":{"name":"sender"}}],[11,"on_drop","","Adds a function to call when session is dropped.",2,{"inputs":[{"name":"self"},{"name":"box"}],"output":null}],[11,"drop","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"sink"}}],[11,"notify","","Sends a notification to a client.",3,{"inputs":[{"name":"self"},{"name":"params"}],"output":{"name":"sinkresult"}}],[11,"start_send","","",3,null],[11,"poll_complete","","",3,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"close","","",3,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"assign_id","","Consumes `Subscriber` and assigns unique id to a requestor. Returns `Err` if request has already terminated.",4,{"inputs":[{"name":"self"},{"name":"subscriptionid"}],"output":{"name":"result"}}],[11,"reject","","Rejects this subscription request with given error. Returns `Err` if request has already terminated.",4,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"subscriptionid"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"subscriptionid"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"subscriptionid"}],"output":{"name":"bool"}}],[11,"hash","","",0,null],[11,"parse_value","","Parses `core::Value` into unique subscription id.",0,{"inputs":[{"name":"value"}],"output":{"name":"option"}}],[6,"TransportError","","Raw transport error.",null,null],[6,"SinkResult","","Subscription send result.",null,null],[8,"SubscribeRpcMethod","","Subscribe handler",null,null],[10,"call","","Called when client is requesting new subscription to be started.",5,{"inputs":[{"name":"self"},{"name":"params"},{"name":"m"},{"name":"subscriber"}],"output":null}],[8,"UnsubscribeRpcMethod","","Unsubscribe handler",null,null],[10,"call","","Called when client is requesting to cancel existing subscription.",6,{"inputs":[{"name":"self"},{"name":"subscriptionid"}],"output":{"name":"boxfuture"}}],[8,"PubSubMetadata","","Metadata extension for pub-sub method handling.",null,null],[10,"session","","Returns session object associated with given request/client. `None` indicates that sessions are not supported on the used transport.",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}]],"paths":[[4,"SubscriptionId"],[3,"PubSubHandler"],[3,"Session"],[3,"Sink"],[3,"Subscriber"],[8,"SubscribeRpcMethod"],[8,"UnsubscribeRpcMethod"],[8,"PubSubMetadata"]]};
searchIndex["jsonrpc_server_utils"] = {"doc":"JSON-RPC servers utilities.","items":[[0,"cors","jsonrpc_server_utils","CORS handling utility functions",null,null],[3,"Origin","jsonrpc_server_utils::cors","Request Origin",null,null],[4,"OriginProtocol","","Origin Protocol",null,null],[13,"Http","","Http protocol",0,null],[13,"Https","","Https protocol",0,null],[13,"Custom","","Custom protocol",0,null],[4,"AccessControlAllowOrigin","","Origins allowed to access",null,null],[13,"Value","","Specific hostname",1,null],[13,"Null","","null-origin (file:///, sandboxed iframe)",1,null],[13,"Any","","Any non-null origin",1,null],[4,"CorsHeader","","CORS Header Result.",null,null],[13,"NotRequired","","CORS header was not required. Origin is not present in the request.",2,null],[13,"Invalid","","CORS header is not returned, Origin is not allowed to access the resource.",2,null],[13,"Ok","","CORS header to include in the response. Origin is allowed to access the resource.",2,null],[5,"get_cors_header","","Returns correct CORS header (if any) given list of allowed origins and current origin.",null,{"inputs":[{"name":"option"},{"name":"option"},{"name":"option"}],"output":{"name":"corsheader"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"originprotocol"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"originprotocol"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"originprotocol"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"origin"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"origin"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"origin"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"new","","Creates new origin given protocol, hostname and port parts. Pre-processes input data if necessary.",3,{"inputs":[{"name":"originprotocol"},{"name":"str"},{"name":"t"}],"output":{"name":"self"}}],[11,"parse","","Attempts to parse given string as a `Origin`. NOTE: This method always succeeds and falls back to sensible defaults.",3,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"matches","","",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"deref","","",3,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"accesscontrolalloworigin"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"accesscontrolalloworigin"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"accesscontrolalloworigin"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",1,{"inputs":[{"name":"t"}],"output":{"name":"accesscontrolalloworigin"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"corsheader"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"corsheader"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"corsheader"}],"output":{"name":"bool"}}],[11,"map","","Maps `Ok` variant of `CorsHeader`.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"corsheader"}}],[11,"into","","",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"hosts","jsonrpc_server_utils","Host header validation.",null,null],[3,"Host","jsonrpc_server_utils::hosts","Host type",null,null],[4,"Port","","Port pattern",null,null],[13,"None","","No port specified (default port)",4,null],[13,"Pattern","","Port specified as a wildcard pattern",4,null],[13,"Fixed","","Fixed numeric port",4,null],[4,"DomainsValidation","","Specifies if domains should be validated.",null,null],[13,"AllowOnly","","Allow only domains on the list.",5,null],[13,"Disabled","","Disable domains validation completely.",5,null],[5,"is_host_valid","","Returns `true` when `Host` header is whitelisted in `allowed_hosts`.",null,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"bool"}}],[5,"update","","Updates given list of hosts with the address.",null,{"inputs":[{"name":"option"},{"name":"socketaddr"}],"output":{"name":"option"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"port"}}],[11,"hash","","",4,null],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"port"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"port"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",4,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"from","","",4,{"inputs":[{"name":"u16"}],"output":{"name":"port"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"host"}}],[11,"hash","","",6,null],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"host"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"host"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",6,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"new","","Creates a new `Host` given hostname and port number.",6,{"inputs":[{"name":"str"},{"name":"t"}],"output":{"name":"self"}}],[11,"parse","","Attempts to parse given string as a `Host`. NOTE: This method always succeeds and falls back to sensible defaults.",6,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"matches","","",6,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"deref","","",6,null],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"domainsvalidation"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"bool"}}],[11,"into","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"from","","",5,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[0,"reactor","jsonrpc_server_utils","Event Loop Remote Either spawns a new event loop, or re-uses provided one.",null,null],[3,"RpcEventLoop","jsonrpc_server_utils::reactor","A handle to running event loop. Dropping the handle will cause event loop to finish.",null,null],[4,"UninitializedRemote","","Possibly uninitialized event loop remote.",null,null],[13,"Shared","","Shared instance of remote.",7,null],[13,"Unspawned","","Event Loop should be spawned by the transport.",7,null],[4,"Remote","","Initialized Remote",null,null],[13,"Shared","","Shared instance",8,null],[13,"Spawned","","Spawned Event Loop",8,null],[11,"initialize","","Initializes remote. In case there is no shared remote, will spawn a new event loop. Dropping `Remote` closes the loop.",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"init_with_name","","Initializes remote. In case there is no shared remote, will spawn a new event loop. Dropping `Remote` closes the loop.",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"remote","","Get remote associated with this event loop.",8,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"close","","Closes underlying event loop (if any!).",8,{"inputs":[{"name":"self"}],"output":null}],[11,"wait","","Wait for underlying event loop to finish (if any!).",8,{"inputs":[{"name":"self"}],"output":null}],[11,"drop","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"spawn","","Spawns a new thread with the `EventLoop`.",9,{"inputs":[],"output":{"name":"result"}}],[11,"with_name","","Spawns a new named thread with the `EventLoop`.",9,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[11,"remote","","Get remote for this event loop.",9,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"wait","","Blocks current thread and waits until the event loop is finished.",9,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","Finishes this event loop.",9,{"inputs":[{"name":"self"}],"output":null}],[8,"Pattern","jsonrpc_server_utils","Pattern that can be matched to string.",null,null],[10,"matches","","Returns true if given string matches the pattern.",10,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}]],"paths":[[4,"OriginProtocol"],[4,"AccessControlAllowOrigin"],[4,"CorsHeader"],[3,"Origin"],[4,"Port"],[4,"DomainsValidation"],[3,"Host"],[4,"UninitializedRemote"],[4,"Remote"],[3,"RpcEventLoop"],[8,"Pattern"]]};
searchIndex["jsonrpc_tcp_server"] = {"doc":"jsonrpc server over tcp/ip","items":[[0,"io","jsonrpc_tcp_server::tokio_core","I/O conveniences when working with primitives in `tokio-core`",null,null],[6,"IoFuture","jsonrpc_tcp_server::tokio_core::io","A convenience typedef around a `Future` whose error component is `io::Error`",null,null],[6,"IoStream","","A convenience typedef around a `Stream` whose error component is `io::Error`",null,null],[8,"Io","","A trait for read/write I/O objects",null,null],[11,"poll_read","","Tests to see if this I/O object may be readable.",0,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Tests to see if this I/O object may be writable.",0,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"read_vec","","Read in a list of buffers all at once.",0,null],[11,"write_vec","","Write a list of buffers all at once.",0,null],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",0,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"framed"}}],[11,"split","","Helper method for splitting this read/write object into two halves.",0,null],[5,"read","","Tries to read some bytes directly into the given `buf` in asynchronous manner, returning a future type.",null,{"inputs":[{"name":"r"},{"name":"t"}],"output":{"name":"read"}}],[3,"Copy","","A future which will copy all data from a reader into a writer.",null,null],[5,"flush","","Creates a future which will entirely flush an I/O object and then yield the object itself.",null,{"inputs":[{"name":"a"}],"output":{"name":"flush"}}],[3,"ReadToEnd","","A future which can be used to easily read the entire contents of a stream into a vector.",null,null],[8,"Codec","","Encoding and decoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",1,null],[16,"Out","","The type of frames to be encoded.",1,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",1,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"result"}}],[11,"decode_eof","","A default method available to be called when there are no more bytes available to be read from the underlying I/O.",1,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"result"}}],[10,"encode","","Encodes a frame into the buffer provided.",1,null],[3,"WriteHalf","","The writable half of an object returned from `Io::split`.",null,null],[5,"copy","","Creates a future which represents copying all the bytes from one object to another.",null,{"inputs":[{"name":"r"},{"name":"w"}],"output":{"name":"copy"}}],[5,"read_to_end","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided.",null,{"inputs":[{"name":"a"},{"name":"vec"}],"output":{"name":"readtoend"}}],[3,"ReadExact","","A future which can be used to easily read exactly enough bytes to fill a buffer.",null,null],[3,"Framed","","A unified `Stream` and `Sink` interface to an underlying `Io` object, using the `Codec` trait to encode and decode frames.",null,null],[5,"write_all","","Creates a future that will write the entire contents of the buffer `buf` to the stream `a` provided.",null,{"inputs":[{"name":"a"},{"name":"t"}],"output":{"name":"writeall"}}],[3,"EasyBufMut","","An RAII object returned from `get_mut` which provides mutable access to the underlying `Vec<u8>`.",null,null],[3,"ReadUntil","","A future which can be used to easily read the contents of a stream into a vector until the delimiter is reached.",null,null],[3,"WriteAll","","A future used to write the entire contents of some data to a stream.",null,null],[3,"ReadHalf","","The readable half of an object returned from `Io::split`.",null,null],[5,"read_until","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided until the delimiter `byte` is reached. This method is the async equivalent to [`BufRead::read_until`].",null,{"inputs":[{"name":"a"},{"name":"u8"},{"name":"vec"}],"output":{"name":"readuntil"}}],[3,"Read","","A future which can be used to easily read available number of bytes to fill a buffer.",null,null],[3,"EasyBuf","","A reference counted buffer of bytes.",null,null],[3,"Flush","","A future used to fully flush an I/O object.",null,null],[3,"Window","","A owned window around an underlying buffer.",null,null],[5,"read_exact","","Creates a future which will read exactly enough bytes to fill `buf`, returning an error if EOF is hit sooner.",null,{"inputs":[{"name":"a"},{"name":"t"}],"output":{"name":"readexact"}}],[0,"net","jsonrpc_tcp_server::tokio_core","TCP/UDP bindings for `tokio-core`",null,null],[8,"UdpCodec","jsonrpc_tcp_server::tokio_core::net","Encoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",2,null],[16,"Out","","The type of frames to be encoded.",2,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",2,null],[10,"encode","","Encodes a frame into the buffer provided.",2,null],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",null,null],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",null,null],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",null,null],[3,"UdpSocket","","An I/O object representing a UDP socket.",null,null],[3,"UdpFramed","","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `UdpCodec` trait to encode and decode frames.",null,null],[3,"TcpStreamNew","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",null,null],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",null,null],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",null,null],[0,"reactor","jsonrpc_tcp_server::tokio_core","The core reactor driving all I/O",null,null],[3,"Core","jsonrpc_tcp_server::tokio_core::reactor","An event loop.",null,null],[3,"CoreId","","An unique ID for a Core",null,null],[3,"Remote","","Handle to an event loop, used to construct I/O objects, send messages, and otherwise interact indirectly with the event loop itself.",null,null],[3,"Handle","","A non-sendable handle to an event loop, useful for manufacturing instances of `LoopData`.",null,null],[3,"Interval","","A stream representing notifications at fixed interval",null,null],[3,"PollEvented","","A concrete implementation of a stream of readiness notifications for I/O objects that originates from an event loop.",null,null],[3,"Timeout","","A future representing the notification that a timeout has occurred.",null,null],[3,"Dispatcher","jsonrpc_tcp_server","Peer-messages dispatcher.",null,null],[3,"RequestContext","","Request context",null,null],[12,"peer_addr","","Peer Address",3,null],[12,"sender","","Peer Sender channel",3,null],[3,"ServerBuilder","","TCP server builder",null,null],[3,"Server","","TCP Server handle",null,null],[4,"PushMessageError","","Push Message Error",null,null],[13,"NoSuchPeer","","Invalid peer",4,null],[13,"Send","","Send error",4,null],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",4,{"inputs":[{"name":"senderror"}],"output":{"name":"self"}}],[11,"new","","Creates a new dispatcher",5,{"inputs":[{"name":"arc"}],"output":{"name":"self"}}],[11,"push_message","","Pushes message to given peer",5,{"inputs":[{"name":"self"},{"name":"socketaddr"},{"name":"string"}],"output":{"name":"result"}}],[11,"is_connected","","Returns `true` if the peer is still connnected",5,{"inputs":[{"name":"self"},{"name":"socketaddr"}],"output":{"name":"bool"}}],[11,"peer_count","","Returns current peer count.",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"new","","Creates new `SeverBuilder` wih given `IoHandler`",6,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"event_loop_remote","","Utilize existing event loop remote.",6,{"inputs":[{"name":"self"},{"name":"remote"}],"output":{"name":"self"}}],[11,"session_meta_extractor","","Sets session meta extractor",6,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"start","","Starts a new server",6,{"inputs":[{"name":"self"},{"name":"socketaddr"}],"output":{"name":"result"}}],[11,"dispatcher","","Returns dispatcher",6,{"inputs":[{"name":"self"}],"output":{"name":"dispatcher"}}],[11,"close","","Closes the server (waits for finish)",7,{"inputs":[{"name":"self"}],"output":null}],[11,"wait","","Wait for the server to finish",7,{"inputs":[{"name":"self"}],"output":null}],[11,"drop","","",7,{"inputs":[{"name":"self"}],"output":null}],[8,"MetaExtractor","","Metadata extractor (per session)",null,null],[10,"extract","","Extracts metadata from request context",8,{"inputs":[{"name":"self"},{"name":"requestcontext"}],"output":{"name":"m"}}],[11,"into","jsonrpc_tcp_server::tokio_core::io","",9,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash","","",9,null],[11,"hash","jsonrpc_tcp_server::tokio_core::reactor","",10,null],[11,"deref","jsonrpc_tcp_server::tokio_core::io","",11,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"start_send","","",12,null],[11,"poll_complete","","",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"start_send","jsonrpc_tcp_server::tokio_core::net","",13,null],[11,"poll_complete","","",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"as_raw_fd","","",14,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"as_raw_fd","","",15,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"as_raw_fd","","",16,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::io","",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::net","",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::reactor","",18,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll_read","jsonrpc_tcp_server::tokio_core::net","",14,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","",14,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"read_vec","","",14,null],[11,"write_vec","","",14,null],[11,"poll_read","jsonrpc_tcp_server::tokio_core::reactor","",19,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","",19,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"partial_cmp","jsonrpc_tcp_server::tokio_core::io","",9,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_tcp_server::tokio_core::net","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_tcp_server::tokio_core::reactor","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::io","",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",25,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",26,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",27,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",28,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",29,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::net","",30,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",31,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",32,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::reactor","",33,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read","jsonrpc_tcp_server::tokio_core::io","",34,null],[11,"read","jsonrpc_tcp_server::tokio_core::net","",14,null],[11,"read","jsonrpc_tcp_server::tokio_core::reactor","",19,null],[11,"write","jsonrpc_tcp_server::tokio_core::io","",35,null],[11,"flush","","",35,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","jsonrpc_tcp_server::tokio_core::net","",14,null],[11,"flush","","",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","jsonrpc_tcp_server::tokio_core::reactor","",19,null],[11,"flush","","",19,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"deref_mut","jsonrpc_tcp_server::tokio_core::io","",11,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"shutdown","jsonrpc_tcp_server::tokio_core::net","",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write_buf","","",14,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[11,"shutdown","jsonrpc_tcp_server::tokio_core::reactor","",19,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"drop","jsonrpc_tcp_server::tokio_core::io","",11,null],[11,"drop","jsonrpc_tcp_server::tokio_core::reactor","",19,null],[11,"drop","","",33,null],[11,"drop","","",18,null],[11,"as_mut","jsonrpc_tcp_server::tokio_core::io","",36,null],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"easybuf"}}],[11,"clone","jsonrpc_tcp_server::tokio_core::reactor","",10,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"as_ref","jsonrpc_tcp_server::tokio_core::io","",9,null],[11,"as_ref","","",36,null],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"eq","jsonrpc_tcp_server::tokio_core::reactor","",10,{"inputs":[{"name":"self"},{"name":"coreid"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"coreid"}],"output":{"name":"bool"}}],[11,"cmp","jsonrpc_tcp_server::tokio_core::io","",9,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"ordering"}}],[11,"from","","",9,{"inputs":[{"name":"vec"}],"output":{"name":"easybuf"}}],[11,"prepare_uninitialized_buffer","jsonrpc_tcp_server::tokio_core::net","",14,null],[11,"read_buf","","",14,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[11,"poll_write","jsonrpc_tcp_server::tokio_core::io","Calls the underlying `poll_write` function on this handling, testing to see if it's ready to be written to.",35,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",12,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",12,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",12,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"poll_read","","Calls the underlying `poll_read` function on this handling, testing to see if it's ready to be read from.",34,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"new","","Creates a new EasyBuf with no data and the default capacity.",9,{"inputs":[],"output":{"name":"easybuf"}}],[11,"with_capacity","","Creates a new EasyBuf with `cap` capacity.",9,{"inputs":[{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"len","","Returns the number of bytes contained in this `EasyBuf`.",9,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"as_slice","","Returns the inner contents of this `EasyBuf` as a slice.",9,null],[11,"split_off","","Splits the buffer into two at the given index.",9,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"drain_to","","Splits the buffer into two at the given index.",9,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"get_mut","","Returns a mutable reference to the underlying growable buffer of bytes.",9,{"inputs":[{"name":"self"}],"output":{"name":"easybufmut"}}],[11,"new","","Creates a new window around the buffer `t` defaulting to the entire slice.",36,{"inputs":[{"name":"t"}],"output":{"name":"window"}}],[11,"get_ref","","Gets a shared reference to the underlying buffer inside of this `Window`.",36,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Gets a mutable reference to the underlying buffer inside of this `Window`.",36,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_inner","","Consumes this `Window`, returning the underlying buffer.",36,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"start","","Returns the starting index of this window into the underlying buffer `T`.",36,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"end","","Returns the end index of this window into the underlying buffer `T`.",36,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"set_start","","Changes the starting index of this window to the index specified.",36,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"window"}}],[11,"set_end","","Changes the end index of this window to the index specified.",36,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"window"}}],[11,"connect","jsonrpc_tcp_server::tokio_core::net","Create a new TCP stream connected to the specified address.",14,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"tcpstreamnew"}}],[11,"from_stream","","Create a new `TcpStream` from a `net::TcpStream`.",14,{"inputs":[{"name":"tcpstream"},{"name":"handle"}],"output":{"name":"result"}}],[11,"connect_stream","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",14,{"inputs":[{"name":"tcpstream"},{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"box"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",14,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",14,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"peer_addr","","Returns the remote address that this stream is connected to.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",14,{"inputs":[{"name":"self"},{"name":"shutdown"}],"output":{"name":"result"}}],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",14,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_keepalive_ms","","Sets whether keepalive messages are enabled to be sent on this socket.",14,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"keepalive_ms","","Returns whether keepalive messages are enabled on this socket, and if so the amount of milliseconds between them.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",14,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Create a new TCP listener associated with this event loop.",15,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_listener","","Create a new TCP listener from the standard library's TCP listener.",15,{"inputs":[{"name":"tcplistener"},{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",15,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"local_addr","","Returns the local address that this listener is bound to.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",15,{"inputs":[{"name":"self"}],"output":{"name":"incoming"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",15,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",15,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Create a new UDP socket bound to the specified address.",16,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"from_socket","","Creates a new `UdpSocket` from the previously bound socket provided.",16,{"inputs":[{"name":"udpsocket"},{"name":"handle"}],"output":{"name":"result"}}],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `UdpSocket` object, using the provided `UdpCodec` to read and write the raw data.",16,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"udpframed"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",16,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",16,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",16,null],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",16,{"inputs":[{"name":"self"},{"name":"t"},{"name":"socketaddr"}],"output":{"name":"senddgram"}}],[11,"recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",16,null],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",16,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"recvdgram"}}],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",16,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",16,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",16,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",16,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",16,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",16,{"inputs":[{"name":"self"},{"name":"ipv4addr"},{"name":"ipv4addr"}],"output":{"name":"result"}}],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",16,{"inputs":[{"name":"self"},{"name":"ipv6addr"},{"name":"u32"}],"output":{"name":"result"}}],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",16,{"inputs":[{"name":"self"},{"name":"ipv4addr"},{"name":"ipv4addr"}],"output":{"name":"result"}}],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",16,{"inputs":[{"name":"self"},{"name":"ipv6addr"},{"name":"u32"}],"output":{"name":"result"}}],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",13,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",13,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",13,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"new","jsonrpc_tcp_server::tokio_core::reactor","Creates a new event loop, returning any error that happened during the creation.",20,{"inputs":[],"output":{"name":"result"}}],[11,"handle","","Returns a handle to this event loop which cannot be sent across threads but can be used as a proxy to the event loop itself.",20,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"remote","","Generates a remote handle to this event loop which can be used to spawn tasks from other threads into this event loop.",20,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"run","","Runs a future until completion, driving the event loop while we're otherwise waiting for the future to complete.",20,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",20,null],[11,"id","","Get the ID of this loop",20,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"spawn","","Spawns a new future into the event loop this remote is associated with.",21,null],[11,"id","","Return the ID of the represented Core",21,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"handle","","Attempts to \"promote\" this remote to a handle, if possible.",21,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"remote","","Returns a reference to the underlying remote handle to the event loop.",22,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"spawn","","Spawns a new future on the event loop this handle is associated with.",22,null],[11,"spawn_fn","","Spawns a closure on this event loop.",22,null],[11,"id","","Return the ID of the represented Core",22,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"new","","Creates a new interval which will fire at `dur` time into the future, and will repeat every `dur` interval after",18,{"inputs":[{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new_at","","Creates a new interval which will fire at the time specified by `at`, and then will repeat every `dur` interval after",18,{"inputs":[{"name":"instant"},{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new","","Creates a new readiness stream associated with the provided `loop_handle` and for the given `source`.",19,{"inputs":[{"name":"e"},{"name":"handle"}],"output":{"name":"result"}}],[11,"deregister","","Deregisters this source of events from the reactor core specified.",19,{"inputs":[{"name":"self"},{"name":"handle"}],"output":{"name":"result"}}],[11,"poll_read","","Tests to see if this source is ready to be read from or not.",19,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Tests to see if this source is ready to be written to or not.",19,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"need_read","","Indicates to this source of events that the corresponding I/O object is no longer readable, but it needs to be.",19,null],[11,"need_write","","Indicates to this source of events that the corresponding I/O object is no longer writable, but it needs to be.",19,null],[11,"remote","","Returns a reference to the event loop handle that this readiness stream is associated with.",19,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",19,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",19,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"new","","Creates a new timeout which will fire at `dur` time into the future.",33,{"inputs":[{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new_at","","Creates a new timeout which will fire at the time specified by `at`.",33,{"inputs":[{"name":"instant"},{"name":"handle"}],"output":{"name":"result"}}]],"paths":[[8,"Io"],[8,"Codec"],[8,"UdpCodec"],[3,"RequestContext"],[4,"PushMessageError"],[3,"Dispatcher"],[3,"ServerBuilder"],[3,"Server"],[8,"MetaExtractor"],[3,"EasyBuf"],[3,"CoreId"],[3,"EasyBufMut"],[3,"Framed"],[3,"UdpFramed"],[3,"TcpStream"],[3,"TcpListener"],[3,"UdpSocket"],[3,"Incoming"],[3,"Interval"],[3,"PollEvented"],[3,"Core"],[3,"Remote"],[3,"Handle"],[3,"Copy"],[3,"Flush"],[3,"ReadExact"],[3,"ReadToEnd"],[3,"Read"],[3,"ReadUntil"],[3,"WriteAll"],[3,"TcpStreamNew"],[3,"SendDgram"],[3,"RecvDgram"],[3,"Timeout"],[3,"ReadHalf"],[3,"WriteHalf"],[3,"Window"]]};
searchIndex["jsonrpc_ws_server"] = {"doc":"`WebSockets` server.","items":[[3,"Origin","jsonrpc_ws_server","Request Origin",null,null],[3,"Host","","Host type",null,null],[4,"DomainsValidation","","Specifies if domains should be validated.",null,null],[13,"AllowOnly","","Allow only domains on the list.",0,null],[13,"Disabled","","Disable domains validation completely.",0,null],[0,"io","jsonrpc_ws_server::tokio_core","I/O conveniences when working with primitives in `tokio-core`",null,null],[6,"IoFuture","jsonrpc_ws_server::tokio_core::io","A convenience typedef around a `Future` whose error component is `io::Error`",null,null],[6,"IoStream","","A convenience typedef around a `Stream` whose error component is `io::Error`",null,null],[8,"Io","","A trait for read/write I/O objects",null,null],[11,"poll_read","","Tests to see if this I/O object may be readable.",1,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Tests to see if this I/O object may be writable.",1,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"read_vec","","Read in a list of buffers all at once.",1,null],[11,"write_vec","","Write a list of buffers all at once.",1,null],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `Io` object, using `Decode` and `Encode` to read and write the raw data.",1,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"framed"}}],[11,"split","","Helper method for splitting this read/write object into two halves.",1,null],[5,"read","","Tries to read some bytes directly into the given `buf` in asynchronous manner, returning a future type.",null,{"inputs":[{"name":"r"},{"name":"t"}],"output":{"name":"read"}}],[3,"Copy","","A future which will copy all data from a reader into a writer.",null,null],[5,"flush","","Creates a future which will entirely flush an I/O object and then yield the object itself.",null,{"inputs":[{"name":"a"}],"output":{"name":"flush"}}],[3,"ReadToEnd","","A future which can be used to easily read the entire contents of a stream into a vector.",null,null],[8,"Codec","","Encoding and decoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",2,null],[16,"Out","","The type of frames to be encoded.",2,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",2,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"result"}}],[11,"decode_eof","","A default method available to be called when there are no more bytes available to be read from the underlying I/O.",2,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"result"}}],[10,"encode","","Encodes a frame into the buffer provided.",2,null],[3,"WriteHalf","","The writable half of an object returned from `Io::split`.",null,null],[5,"copy","","Creates a future which represents copying all the bytes from one object to another.",null,{"inputs":[{"name":"r"},{"name":"w"}],"output":{"name":"copy"}}],[5,"read_to_end","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided.",null,{"inputs":[{"name":"a"},{"name":"vec"}],"output":{"name":"readtoend"}}],[3,"ReadExact","","A future which can be used to easily read exactly enough bytes to fill a buffer.",null,null],[3,"Framed","","A unified `Stream` and `Sink` interface to an underlying `Io` object, using the `Codec` trait to encode and decode frames.",null,null],[5,"write_all","","Creates a future that will write the entire contents of the buffer `buf` to the stream `a` provided.",null,{"inputs":[{"name":"a"},{"name":"t"}],"output":{"name":"writeall"}}],[3,"EasyBufMut","","An RAII object returned from `get_mut` which provides mutable access to the underlying `Vec<u8>`.",null,null],[3,"ReadUntil","","A future which can be used to easily read the contents of a stream into a vector until the delimiter is reached.",null,null],[3,"WriteAll","","A future used to write the entire contents of some data to a stream.",null,null],[3,"ReadHalf","","The readable half of an object returned from `Io::split`.",null,null],[5,"read_until","","Creates a future which will read all the bytes associated with the I/O object `A` into the buffer provided until the delimiter `byte` is reached. This method is the async equivalent to [`BufRead::read_until`].",null,{"inputs":[{"name":"a"},{"name":"u8"},{"name":"vec"}],"output":{"name":"readuntil"}}],[3,"Read","","A future which can be used to easily read available number of bytes to fill a buffer.",null,null],[3,"EasyBuf","","A reference counted buffer of bytes.",null,null],[3,"Flush","","A future used to fully flush an I/O object.",null,null],[3,"Window","","A owned window around an underlying buffer.",null,null],[5,"read_exact","","Creates a future which will read exactly enough bytes to fill `buf`, returning an error if EOF is hit sooner.",null,{"inputs":[{"name":"a"},{"name":"t"}],"output":{"name":"readexact"}}],[0,"net","jsonrpc_ws_server::tokio_core","TCP/UDP bindings for `tokio-core`",null,null],[8,"UdpCodec","jsonrpc_ws_server::tokio_core::net","Encoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",3,null],[16,"Out","","The type of frames to be encoded.",3,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",3,null],[10,"encode","","Encodes a frame into the buffer provided.",3,null],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",null,null],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",null,null],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",null,null],[3,"UdpSocket","","An I/O object representing a UDP socket.",null,null],[3,"UdpFramed","","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `UdpCodec` trait to encode and decode frames.",null,null],[3,"TcpStreamNew","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",null,null],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",null,null],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",null,null],[0,"reactor","jsonrpc_ws_server::tokio_core","The core reactor driving all I/O",null,null],[3,"Core","jsonrpc_ws_server::tokio_core::reactor","An event loop.",null,null],[3,"CoreId","","An unique ID for a Core",null,null],[3,"Remote","","Handle to an event loop, used to construct I/O objects, send messages, and otherwise interact indirectly with the event loop itself.",null,null],[3,"Handle","","A non-sendable handle to an event loop, useful for manufacturing instances of `LoopData`.",null,null],[3,"Interval","","A stream representing notifications at fixed interval",null,null],[3,"PollEvented","","A concrete implementation of a stream of readiness notifications for I/O objects that originates from an event loop.",null,null],[3,"Timeout","","A future representing the notification that a timeout has occurred.",null,null],[3,"RequestContext","jsonrpc_ws_server","Request context",null,null],[12,"session_id","","Session id",4,null],[12,"origin","","Request Origin",4,null],[12,"protocols","","Requested protocols",4,null],[12,"out","","Direct channel to send messages to a client.",4,null],[12,"remote","","Remote to underlying event loop.",4,null],[3,"NoopExtractor","","Dummy metadata extractor",null,null],[3,"Server","","`WebSockets` server implementation.",null,null],[3,"ServerBuilder","","Builder for `WebSockets` server",null,null],[4,"MiddlewareAction","","Request middleware action",null,null],[13,"Proceed","","Proceed with standard JSON-RPC behaviour.",5,null],[13,"Respond","","Terminate the request and return a response.",5,null],[12,"response","jsonrpc_ws_server::MiddlewareAction","Response to return",5,null],[12,"validate_origin","","Should origin be validated before returning the response?",5,null],[12,"validate_hosts","","Should hosts be validated before returning the response?",5,null],[4,"Error","jsonrpc_ws_server","Signer startup error",null,null],[13,"Io","","Wrapped `std::io::Error`",6,null],[13,"WebSocket","","Other `ws-rs` error",6,null],[11,"sender","","Get this session as a `Sink` spawning a new future in the underlying event loop.",4,{"inputs":[{"name":"self"}],"output":{"name":"sender"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"noopextractor"}}],[11,"addr","","Returns the address this server is listening on",8,{"inputs":[{"name":"self"}],"output":{"name":"socketaddr"}}],[11,"start","","Starts a new `WebSocket` server in separate thread. Returns a `Server` handle which closes the server when droped.",8,{"inputs":[{"name":"socketaddr"},{"name":"arc"},{"name":"arc"},{"name":"option"},{"name":"option"},{"name":"option"},{"name":"option"},{"name":"uninitializedremote"}],"output":{"name":"result"}}],[11,"wait","","Consumes the server and waits for completion",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","Closes the server and waits for it to finish",8,{"inputs":[{"name":"self"}],"output":null}],[11,"drop","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",6,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",6,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",6,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Creates new `ServerBuilder`",9,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"event_loop_remote","","Utilize existing event loop remote to poll RPC results.",9,{"inputs":[{"name":"self"},{"name":"remote"}],"output":{"name":"self"}}],[11,"session_meta_extractor","","Sets a meta extractor.",9,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"allowed_origins","","Allowed origins.",9,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"self"}}],[11,"allowed_hosts","","Allowed hosts.",9,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"self"}}],[11,"session_stats","","Session stats",9,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"request_middleware","","Sets a request middleware. Middleware will be invoked before each handshake request. You can either terminate the handshake in the middleware or run a default behaviour after.",9,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"start","","Starts a new `WebSocket` server in separate thread. Returns a `Server` handle which closes the server when droped.",9,{"inputs":[{"name":"self"},{"name":"socketaddr"}],"output":{"name":"result"}}],[11,"from","","",5,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[6,"SessionId","","Session id",null,null],[8,"MetaExtractor","","Metadata extractor from session data.",null,null],[11,"extract","","Extract metadata for given session",10,{"inputs":[{"name":"self"},{"name":"requestcontext"}],"output":{"name":"m"}}],[8,"SessionStats","","Keeps track of open sessions",null,null],[10,"open_session","","Executed when new session is opened.",11,{"inputs":[{"name":"self"},{"name":"sessionid"}],"output":null}],[10,"close_session","","Executed when session is closed.",11,{"inputs":[{"name":"self"},{"name":"sessionid"}],"output":null}],[8,"RequestMiddleware","","Middleware to intercept server requests. You can either terminate the request (by returning a response) or just proceed with standard JSON-RPC handling.",null,null],[10,"process","","Process a request and decide what to do next.",12,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"middlewareaction"}}],[11,"new","","Creates new origin given protocol, hostname and port parts. Pre-processes input data if necessary.",13,{"inputs":[{"name":"originprotocol"},{"name":"str"},{"name":"t"}],"output":{"name":"origin"}}],[11,"parse","","Attempts to parse given string as a `Origin`. NOTE: This method always succeeds and falls back to sensible defaults.",13,{"inputs":[{"name":"str"}],"output":{"name":"origin"}}],[11,"into","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"hash","","",14,null],[11,"deref","","",13,null],[11,"deref","","",14,null],[11,"matches","","",13,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"matches","","",14,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"origin"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"host"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"domainsvalidation"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"origin"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"origin"}],"output":{"name":"bool"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"host"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"host"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"domainsvalidation"}],"output":{"name":"bool"}}],[11,"from","","",13,{"inputs":[{"name":"t"}],"output":{"name":"origin"}}],[11,"from","","",14,{"inputs":[{"name":"t"}],"output":{"name":"host"}}],[11,"from","","",0,{"inputs":[{"name":"option"}],"output":{"name":"domainsvalidation"}}],[11,"into","jsonrpc_ws_server::tokio_core::io","",15,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash","","",15,null],[11,"hash","jsonrpc_ws_server::tokio_core::reactor","",16,null],[11,"deref","jsonrpc_ws_server::tokio_core::io","",17,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"start_send","","",18,null],[11,"poll_complete","","",18,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","",18,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"start_send","jsonrpc_ws_server::tokio_core::net","",19,null],[11,"poll_complete","","",19,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"close","","",19,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"as_raw_fd","","",20,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"as_raw_fd","","",21,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"as_raw_fd","","",22,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"poll","jsonrpc_ws_server::tokio_core::io","",18,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::net","",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",19,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::reactor","",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll_read","jsonrpc_ws_server::tokio_core::net","",20,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","",20,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"read_vec","","",20,null],[11,"write_vec","","",20,null],[11,"poll_read","jsonrpc_ws_server::tokio_core::reactor","",25,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","",25,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"partial_cmp","jsonrpc_ws_server::tokio_core::io","",15,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_ws_server::tokio_core::net","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","jsonrpc_ws_server::tokio_core::reactor","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::io","",29,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",30,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",31,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",32,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",33,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",34,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",35,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::net","",36,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","",38,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::reactor","",39,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read","jsonrpc_ws_server::tokio_core::io","",40,null],[11,"read","jsonrpc_ws_server::tokio_core::net","",20,null],[11,"read","jsonrpc_ws_server::tokio_core::reactor","",25,null],[11,"write","jsonrpc_ws_server::tokio_core::io","",41,null],[11,"flush","","",41,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","jsonrpc_ws_server::tokio_core::net","",20,null],[11,"flush","","",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","jsonrpc_ws_server::tokio_core::reactor","",25,null],[11,"flush","","",25,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"deref_mut","jsonrpc_ws_server::tokio_core::io","",17,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"shutdown","jsonrpc_ws_server::tokio_core::net","",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write_buf","","",20,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[11,"shutdown","jsonrpc_ws_server::tokio_core::reactor","",25,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"drop","jsonrpc_ws_server::tokio_core::io","",17,null],[11,"drop","jsonrpc_ws_server::tokio_core::reactor","",25,null],[11,"drop","","",39,null],[11,"drop","","",24,null],[11,"as_mut","jsonrpc_ws_server::tokio_core::io","",42,null],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"easybuf"}}],[11,"clone","jsonrpc_ws_server::tokio_core::reactor","",16,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"as_ref","jsonrpc_ws_server::tokio_core::io","",15,null],[11,"as_ref","","",42,null],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"eq","jsonrpc_ws_server::tokio_core::reactor","",16,{"inputs":[{"name":"self"},{"name":"coreid"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"coreid"}],"output":{"name":"bool"}}],[11,"cmp","jsonrpc_ws_server::tokio_core::io","",15,{"inputs":[{"name":"self"},{"name":"easybuf"}],"output":{"name":"ordering"}}],[11,"from","","",15,{"inputs":[{"name":"vec"}],"output":{"name":"easybuf"}}],[11,"prepare_uninitialized_buffer","jsonrpc_ws_server::tokio_core::net","",20,null],[11,"read_buf","","",20,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[11,"new","jsonrpc_ws_server","Creates a new `Host` given hostname and port number.",14,{"inputs":[{"name":"str"},{"name":"t"}],"output":{"name":"host"}}],[11,"parse","","Attempts to parse given string as a `Host`. NOTE: This method always succeeds and falls back to sensible defaults.",14,{"inputs":[{"name":"str"}],"output":{"name":"host"}}],[11,"poll_write","jsonrpc_ws_server::tokio_core::io","Calls the underlying `poll_write` function on this handling, testing to see if it's ready to be written to.",41,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",18,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",18,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",18,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"poll_read","","Calls the underlying `poll_read` function on this handling, testing to see if it's ready to be read from.",40,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"new","","Creates a new EasyBuf with no data and the default capacity.",15,{"inputs":[],"output":{"name":"easybuf"}}],[11,"with_capacity","","Creates a new EasyBuf with `cap` capacity.",15,{"inputs":[{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"len","","Returns the number of bytes contained in this `EasyBuf`.",15,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"as_slice","","Returns the inner contents of this `EasyBuf` as a slice.",15,null],[11,"split_off","","Splits the buffer into two at the given index.",15,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"drain_to","","Splits the buffer into two at the given index.",15,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"easybuf"}}],[11,"get_mut","","Returns a mutable reference to the underlying growable buffer of bytes.",15,{"inputs":[{"name":"self"}],"output":{"name":"easybufmut"}}],[11,"new","","Creates a new window around the buffer `t` defaulting to the entire slice.",42,{"inputs":[{"name":"t"}],"output":{"name":"window"}}],[11,"get_ref","","Gets a shared reference to the underlying buffer inside of this `Window`.",42,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Gets a mutable reference to the underlying buffer inside of this `Window`.",42,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_inner","","Consumes this `Window`, returning the underlying buffer.",42,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"start","","Returns the starting index of this window into the underlying buffer `T`.",42,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"end","","Returns the end index of this window into the underlying buffer `T`.",42,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"set_start","","Changes the starting index of this window to the index specified.",42,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"window"}}],[11,"set_end","","Changes the end index of this window to the index specified.",42,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"window"}}],[11,"connect","jsonrpc_ws_server::tokio_core::net","Create a new TCP stream connected to the specified address.",20,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"tcpstreamnew"}}],[11,"from_stream","","Create a new `TcpStream` from a `net::TcpStream`.",20,{"inputs":[{"name":"tcpstream"},{"name":"handle"}],"output":{"name":"result"}}],[11,"connect_stream","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",20,{"inputs":[{"name":"tcpstream"},{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"box"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",20,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",20,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"peer_addr","","Returns the remote address that this stream is connected to.",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",20,{"inputs":[{"name":"self"},{"name":"shutdown"}],"output":{"name":"result"}}],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",20,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_keepalive_ms","","Sets whether keepalive messages are enabled to be sent on this socket.",20,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"keepalive_ms","","Returns whether keepalive messages are enabled on this socket, and if so the amount of milliseconds between them.",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",20,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Create a new TCP listener associated with this event loop.",21,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",21,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_listener","","Create a new TCP listener from the standard library's TCP listener.",21,{"inputs":[{"name":"tcplistener"},{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",21,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"local_addr","","Returns the local address that this listener is bound to.",21,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",21,{"inputs":[{"name":"self"}],"output":{"name":"incoming"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",21,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",21,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",21,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",21,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Create a new UDP socket bound to the specified address.",22,{"inputs":[{"name":"socketaddr"},{"name":"handle"}],"output":{"name":"result"}}],[11,"from_socket","","Creates a new `UdpSocket` from the previously bound socket provided.",22,{"inputs":[{"name":"udpsocket"},{"name":"handle"}],"output":{"name":"result"}}],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `UdpSocket` object, using the provided `UdpCodec` to read and write the raw data.",22,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"udpframed"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",22,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",22,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",22,null],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",22,{"inputs":[{"name":"self"},{"name":"t"},{"name":"socketaddr"}],"output":{"name":"senddgram"}}],[11,"recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",22,null],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",22,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"recvdgram"}}],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",22,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",22,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",22,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",22,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",22,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",22,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",22,{"inputs":[{"name":"self"},{"name":"ipv4addr"},{"name":"ipv4addr"}],"output":{"name":"result"}}],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",22,{"inputs":[{"name":"self"},{"name":"ipv6addr"},{"name":"u32"}],"output":{"name":"result"}}],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",22,{"inputs":[{"name":"self"},{"name":"ipv4addr"},{"name":"ipv4addr"}],"output":{"name":"result"}}],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",22,{"inputs":[{"name":"self"},{"name":"ipv6addr"},{"name":"u32"}],"output":{"name":"result"}}],[11,"get_ref","","Returns a reference to the underlying I/O stream wrapped by `Framed`.",19,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",19,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",19,{"inputs":[{"name":"self"}],"output":{"name":"udpsocket"}}],[11,"new","jsonrpc_ws_server::tokio_core::reactor","Creates a new event loop, returning any error that happened during the creation.",26,{"inputs":[],"output":{"name":"result"}}],[11,"handle","","Returns a handle to this event loop which cannot be sent across threads but can be used as a proxy to the event loop itself.",26,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"remote","","Generates a remote handle to this event loop which can be used to spawn tasks from other threads into this event loop.",26,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"run","","Runs a future until completion, driving the event loop while we're otherwise waiting for the future to complete.",26,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",26,null],[11,"id","","Get the ID of this loop",26,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"spawn","","Spawns a new future into the event loop this remote is associated with.",27,null],[11,"id","","Return the ID of the represented Core",27,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"handle","","Attempts to \"promote\" this remote to a handle, if possible.",27,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"remote","","Returns a reference to the underlying remote handle to the event loop.",28,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"spawn","","Spawns a new future on the event loop this handle is associated with.",28,null],[11,"spawn_fn","","Spawns a closure on this event loop.",28,null],[11,"id","","Return the ID of the represented Core",28,{"inputs":[{"name":"self"}],"output":{"name":"coreid"}}],[11,"new","","Creates a new interval which will fire at `dur` time into the future, and will repeat every `dur` interval after",24,{"inputs":[{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new_at","","Creates a new interval which will fire at the time specified by `at`, and then will repeat every `dur` interval after",24,{"inputs":[{"name":"instant"},{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new","","Creates a new readiness stream associated with the provided `loop_handle` and for the given `source`.",25,{"inputs":[{"name":"e"},{"name":"handle"}],"output":{"name":"result"}}],[11,"deregister","","Deregisters this source of events from the reactor core specified.",25,{"inputs":[{"name":"self"},{"name":"handle"}],"output":{"name":"result"}}],[11,"poll_read","","Tests to see if this source is ready to be read from or not.",25,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"poll_write","","Tests to see if this source is ready to be written to or not.",25,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"need_read","","Indicates to this source of events that the corresponding I/O object is no longer readable, but it needs to be.",25,null],[11,"need_write","","Indicates to this source of events that the corresponding I/O object is no longer writable, but it needs to be.",25,null],[11,"remote","","Returns a reference to the event loop handle that this readiness stream is associated with.",25,{"inputs":[{"name":"self"}],"output":{"name":"remote"}}],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",25,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",25,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"new","","Creates a new timeout which will fire at `dur` time into the future.",39,{"inputs":[{"name":"duration"},{"name":"handle"}],"output":{"name":"result"}}],[11,"new_at","","Creates a new timeout which will fire at the time specified by `at`.",39,{"inputs":[{"name":"instant"},{"name":"handle"}],"output":{"name":"result"}}],[11,"extract","jsonrpc_ws_server","Extract metadata for given session",10,{"inputs":[{"name":"self"},{"name":"requestcontext"}],"output":{"name":"m"}}]],"paths":[[4,"DomainsValidation"],[8,"Io"],[8,"Codec"],[8,"UdpCodec"],[3,"RequestContext"],[4,"MiddlewareAction"],[4,"Error"],[3,"NoopExtractor"],[3,"Server"],[3,"ServerBuilder"],[8,"MetaExtractor"],[8,"SessionStats"],[8,"RequestMiddleware"],[3,"Origin"],[3,"Host"],[3,"EasyBuf"],[3,"CoreId"],[3,"EasyBufMut"],[3,"Framed"],[3,"UdpFramed"],[3,"TcpStream"],[3,"TcpListener"],[3,"UdpSocket"],[3,"Incoming"],[3,"Interval"],[3,"PollEvented"],[3,"Core"],[3,"Remote"],[3,"Handle"],[3,"Copy"],[3,"Flush"],[3,"ReadExact"],[3,"ReadToEnd"],[3,"Read"],[3,"ReadUntil"],[3,"WriteAll"],[3,"TcpStreamNew"],[3,"SendDgram"],[3,"RecvDgram"],[3,"Timeout"],[3,"ReadHalf"],[3,"WriteHalf"],[3,"Window"]]};
initSearch(searchIndex);
